package com.claudecodeplus.mcp

import com.claudecodeplus.mcp.models.*
import com.claudecodeplus.mcp.server.StandardizedIdeaMcpServer
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.project.ProjectManager
import kotlinx.coroutines.*
import kotlinx.serialization.json.Json
import java.io.File
import kotlin.system.measureTimeMillis

/**
 * 真实 API 测试
 * 测试真正调用 IntelliJ Platform API 的 MCP 服务器
 */
object RealApiTest {
    
    @JvmStatic
    fun main(args: Array<String>) {
        println("🔧 真实 IntelliJ Platform API 测试")
        println("=" * 50)
        
        try {
            // 注意：这个测试需要在真正的 IntelliJ Platform 环境中运行
            println("⚠️  注意：此测试需要在 IntelliJ Platform 插件环境中运行")
            println("📍 当前运行模式：模拟测试（演示 API 调用格式）")
            
            runBlocking {
                demonstrateApiCalls()
            }
            
        } catch (e: Exception) {
            println("❌ 测试执行失败: ${e.message}")
            println("💡 这是正常的，因为当前不在 IntelliJ Platform 环境中")
        }
        
        println("\n" + "=" * 50)
        println("✅ API 格式和参数结构验证完成！")
    }
    
    private suspend fun demonstrateApiCalls() {
        println("\n📋 演示标准化 MCP 工具调用格式：")
        
        // 1. 演示 check_file_errors 工具调用
        demonstrateCheckFileErrors()
        
        // 2. 演示 analyze_code_quality 工具调用
        demonstrateAnalyzeCodeQuality()
        
        // 3. 演示 validate_syntax 工具调用
        demonstrateValidateSyntax()
        
        // 4. 演示 get_inspection_results 工具调用
        demonstrateGetInspectionResults()
        
        // 5. 演示批量操作
        demonstrateBatchOperations()
    }
    
    private fun demonstrateCheckFileErrors() {
        println("\n🔍 1. check_file_errors 工具参数格式：")
        
        val request = CheckFileErrorsRequest(
            filePath = "/project/src/main/kotlin/com/example/MyClass.kt",
            checkLevel = "all",
            includeInspections = true,
            maxErrors = 50,
            timeout = 30000
        )
        
        val json = Json { prettyPrint = true }
        println("   请求参数 JSON：")
        println("   " + json.encodeToString(CheckFileErrorsRequest.serializer(), request).prependIndent("   "))
        
        val expectedResponse = McpToolResponse(
            tool = "check_file_errors",
            success = true,
            result = FileErrorCheckResult(
                filePath = request.filePath,
                fileExists = true,
                fileSize = 2048,
                lineCount = 45,
                language = "Kotlin",
                summary = ErrorSummary(
                    totalIssues = 3,
                    errorCount = 1,
                    warningCount = 2,
                    infoCount = 0,
                    categories = mapOf(
                        "Syntax" to 1,
                        "Unused" to 1,
                        "Nullability" to 1
                    )
                ),
                issues = listOf(
                    CodeIssue(
                        severity = "ERROR",
                        message = "Unresolved reference: unknownFunction",
                        category = "Syntax",
                        line = 12,
                        column = 5,
                        source = "IDE"
                    ),
                    CodeIssue(
                        severity = "WARNING",
                        message = "Unused variable 'temp'",
                        category = "Unused",
                        line = 8,
                        column = 9,
                        source = "IDE"
                    )
                )
            ),
            metadata = McpMetadata(executionTime = 150)
        )
        
        println("\n   响应格式示例：")
        println("   " + json.encodeToString(McpToolResponse.serializer(), expectedResponse).prependIndent("   "))
    }
    
    private fun demonstrateAnalyzeCodeQuality() {
        println("\n📊 2. analyze_code_quality 工具参数格式：")
        
        val request = AnalyzeCodeQualityRequest(
            filePath = "/project/src/main/kotlin/com/example/ComplexClass.kt",
            metrics = listOf("complexity", "duplicates", "maintainability"),
            includeDetails = true,
            threshold = CodeQualityThreshold(
                maxComplexity = 8,
                maxMethodLines = 40,
                maxDuplicatePercentage = 15,
                minMaintainabilityIndex = 65
            )
        )
        
        val json = Json { prettyPrint = true }
        println("   请求参数 JSON：")
        println("   " + json.encodeToString(AnalyzeCodeQualityRequest.serializer(), request).prependIndent("   "))
        
        val expectedResponse = McpToolResponse(
            tool = "analyze_code_quality",
            success = true,
            result = CodeQualityResult(
                filePath = request.filePath,
                language = "Kotlin",
                summary = QualitySummary(
                    overallScore = 7.2,
                    grade = "B+",
                    status = "good",
                    riskLevel = "low"
                ),
                metrics = QualityMetrics(
                    fileMetrics = FileMetrics(
                        totalLines = 156,
                        codeLines = 120,
                        commentLines = 25,
                        blankLines = 11,
                        fileSize = 4096,
                        characterCount = 3892
                    ),
                    complexityMetrics = ComplexityMetrics(
                        cyclomaticComplexity = 12,
                        complexityScore = 6.8,
                        methodCount = 8,
                        classCount = 2,
                        averageMethodLength = 15.0,
                        maxMethodComplexity = 8,
                        complexMethods = listOf("processData", "validateInput")
                    )
                ),
                recommendations = listOf(
                    QualityRecommendation(
                        type = "refactor",
                        priority = "medium",
                        category = "complexity",
                        message = "Consider splitting the 'processData' method to reduce complexity",
                        estimatedEffort = "30m",
                        impact = "high"
                    )
                )
            ),
            metadata = McpMetadata(executionTime = 280)
        )
        
        println("\n   响应格式示例（简化）：")
        println("   工具: ${expectedResponse.tool}")
        println("   成功: ${expectedResponse.success}")
        println("   总体评分: ${expectedResponse.result?.summary?.overallScore}")
        println("   等级: ${expectedResponse.result?.summary?.grade}")
        println("   执行时间: ${expectedResponse.metadata.executionTime}ms")
    }
    
    private fun demonstrateValidateSyntax() {
        println("\n🔍 3. validate_syntax 工具参数格式：")
        
        val request = ValidateSyntaxRequest(
            filePath = "/project/src/main/kotlin/com/example/TestClass.kt",
            strict = false,
            includeWarnings = true
        )
        
        val json = Json { prettyPrint = true }
        println("   请求参数 JSON：")
        println("   " + json.encodeToString(ValidateSyntaxRequest.serializer(), request).prependIndent("   "))
        
        println("\n   响应格式示例：")
        println("   {")
        println("     \"tool\": \"validate_syntax\",")
        println("     \"success\": true,")
        println("     \"result\": {")
        println("       \"filePath\": \"${request.filePath}\",")
        println("       \"isValid\": false,")
        println("       \"language\": \"Kotlin\",")
        println("       \"summary\": {")
        println("         \"totalErrors\": 2,")
        println("         \"errorTypes\": [\"MISSING_SEMICOLON\", \"UNEXPECTED_TOKEN\"],")
        println("         \"severity\": \"minor\",")
        println("         \"parseSuccess\": false")
        println("       }")
        println("     }")
        println("   }")
    }
    
    private fun demonstrateGetInspectionResults() {
        println("\n🔍 4. get_inspection_results 工具参数格式：")
        
        val request = GetInspectionResultsRequest(
            filePath = "/project/src/main/kotlin/com/example/MyClass.kt",
            inspectionNames = listOf("UnusedDeclaration", "NullableProblems", "RedundantSemicolon"),
            severity = "warning",
            includeDescription = true
        )
        
        val json = Json { prettyPrint = true }
        println("   请求参数 JSON：")
        println("   " + json.encodeToString(GetInspectionResultsRequest.serializer(), request).prependIndent("   "))
        
        println("\n   响应格式示例：")
        println("   包含详细的 IntelliJ 检查结果，按检查类型分组")
    }
    
    private fun demonstrateBatchOperations() {
        println("\n🔄 5. batch_analyze_files 批量操作格式：")
        
        val request = BatchAnalyzeFilesRequest(
            filePaths = listOf(
                "/project/src/main/kotlin/com/example/ClassA.kt",
                "/project/src/main/kotlin/com/example/ClassB.kt",
                "/project/src/main/kotlin/com/example/ClassC.kt"
            ),
            operations = listOf("errors", "quality", "syntax"),
            parallel = true,
            maxConcurrency = 3
        )
        
        val json = Json { prettyPrint = true }
        println("   请求参数 JSON：")
        println("   " + json.encodeToString(BatchAnalyzeFilesRequest.serializer(), request).prependIndent("   "))
        
        println("\n   响应格式示例：")
        println("   包含所有文件的分析结果汇总和统计信息")
    }
    
    private operator fun String.times(n: Int) = this.repeat(n)
}

/**
 * MCP 工具参数验证器
 */
object McpParameterValidator {
    
    fun validateCheckFileErrorsRequest(request: CheckFileErrorsRequest): List<String> {
        val errors = mutableListOf<String>()
        
        if (request.filePath.isBlank()) {
            errors.add("filePath 不能为空")
        }
        
        if (!File(request.filePath).exists()) {
            errors.add("文件不存在: ${request.filePath}")
        }
        
        if (request.checkLevel !in listOf("error", "warning", "all")) {
            errors.add("checkLevel 必须是 error, warning 或 all")
        }
        
        if (request.maxErrors < 1 || request.maxErrors > 1000) {
            errors.add("maxErrors 必须在 1-1000 之间")
        }
        
        return errors
    }
    
    fun validateAnalyzeCodeQualityRequest(request: AnalyzeCodeQualityRequest): List<String> {
        val errors = mutableListOf<String>()
        
        if (request.filePath.isBlank()) {
            errors.add("filePath 不能为空")
        }
        
        val validMetrics = setOf("complexity", "duplicates", "maintainability", "coverage", "documentation")
        val invalidMetrics = request.metrics - validMetrics
        
        if (invalidMetrics.isNotEmpty()) {
            errors.add("无效的指标: ${invalidMetrics.joinToString(", ")}")
        }
        
        return errors
    }
}

/**
 * MCP 响应格式化器
 */
object McpResponseFormatter {
    
    fun formatFileErrorResponse(result: FileErrorCheckResult): String {
        val sb = StringBuilder()
        sb.appendLine("📁 文件: ${result.filePath}")
        sb.appendLine("📊 汇总: ${result.summary.totalIssues} 个问题 (${result.summary.errorCount} 错误, ${result.summary.warningCount} 警告)")
        
        if (result.issues.isNotEmpty()) {
            sb.appendLine("🔍 问题详情:")
            result.issues.take(5).forEach { issue ->
                sb.appendLine("  ${issue.severity} - ${issue.message} (${issue.line}:${issue.column})")
            }
            
            if (result.issues.size > 5) {
                sb.appendLine("  ... 还有 ${result.issues.size - 5} 个问题")
            }
        }
        
        return sb.toString()
    }
    
    fun formatCodeQualityResponse(result: CodeQualityResult): String {
        val sb = StringBuilder()
        sb.appendLine("📊 代码质量报告: ${result.filePath}")
        sb.appendLine("🎯 总体评分: ${result.summary.overallScore}/10 (${result.summary.grade})")
        sb.appendLine("📈 状态: ${result.summary.status}")
        sb.appendLine("⚠️  风险级别: ${result.summary.riskLevel}")
        
        result.metrics.complexityMetrics?.let { complexity ->
            sb.appendLine("🔢 复杂度: ${complexity.cyclomaticComplexity}")
            sb.appendLine("📏 方法数: ${complexity.methodCount}")
        }
        
        if (result.recommendations.isNotEmpty()) {
            sb.appendLine("💡 改进建议:")
            result.recommendations.take(3).forEach { rec ->
                sb.appendLine("  ${rec.priority.uppercase()} - ${rec.message}")
            }
        }
        
        return sb.toString()
    }
}