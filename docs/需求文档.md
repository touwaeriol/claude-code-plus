# Claude Code Plus 需求文档

## 1. 项目概述

Claude Code Plus 是一个 IntelliJ IDEA 插件，提供类似 JetBrains AI Assistant 的聊天界面，用于与 Claude SDK 进行交互。

## 2. UI 界面需求

### 2.1 工具窗口
- **位置**：IDE 右侧边栏
- **图标**：Claude Code 自定义图标
- **标题**：Claude Code

### 2.2 聊天界面布局

```
+----------------------------------+
|          工具栏                   |
| [新会话] [清空] [日志] [导出]      |
| [显示工具调用: ✓]                 |
+----------------------------------+
|                                  |
|          消息显示区域              |
|    （Markdown 渲染）              |
|                                  |
|                                  |
+----------------------------------+
|          状态栏                   |
|  会话ID: xxx | 消息数: 12         |
+----------------------------------+
|          输入区域                 |
|  [输入框..................] [发送] |
+----------------------------------+
```

### 2.3 消息显示格式

#### 用户消息
- **复用输入框组件设计** - 使用与 ChatInputArea 相同的视觉设计和布局
- **只读显示模式** - 不可编辑，不可交互
- **显示内容**：
  - 用户实际输入的文本内容
  - 选择的上下文标签（文件、网页等）
  - 使用的AI模型（显示但不可切换）
- **隐藏元素**：
  - Add Context 按钮（用户已完成输入）
  - 发送按钮（消息已发送）
- **保持一致性**：
  - 统一的边框和背景设计
  - 相同的间距和字体规范
  - 与输入框相同的视觉层次结构

#### 助手消息  
- 直接显示在主背景上，无额外背景容器
- 无需显示发送者标识
- 通过背景色差异自然区分对话双方
- 保持良好的可读性和对比度

#### 处理状态
- 在助手回复区域显示"Generating..."文本
- 提供"Stop"按钮允许中断生成
- 生成完成后自动隐藏状态提示

#### 工具调用消息（紧凑模式）
```markdown
🔧 **工具调用**: `read_file` ➡️ `MainActivity.kt` [查看详情]
```

#### 工具调用消息（展开模式）
```markdown
🔧 **工具调用**: read_file
参数: 
```json
{
  "path": "/src/MainActivity.kt",
  "line_start": 1,
  "line_end": 50
}
```
📋 **结果**: 50 行代码已读取
```

#### 系统消息
- 不显示发送者标识
- 直接显示内容
- 用于欢迎消息、状态提示等

#### 错误消息
```markdown
### ❌ Error

> 错误信息内容

---
```

## 3. 功能需求

### 3.0 工具消息显示控制
- **显示开关**：工具栏中提供“显示工具调用”复选框
- **显示模式**：
  - 隐藏：完全不显示工具调用信息
  - 紧凑：单行显示工具名称和关键参数
  - 展开：显示完整的工具调用参数和结果
- **交互设计**：
  - 紧凑模式下，点击“[查看详情]”可以展开单个工具调用
  - 展开后可以点击“[收起]”恢复紧凑显示
  - 工具结果过长时自动折叠，显示前100字符和“...”

### 3.1 基础聊天功能
- **发送消息**：用户在输入框输入内容，按 Enter 或点击发送按钮
- **接收回复**：实时显示 Claude 的流式响应
- **消息历史**：保持对话上下文，支持滚动查看历史消息

### 3.2 会话管理
- **新会话**：清空当前对话，开始新的会话
- **会话持续**：在同一会话中保持上下文
- **首条消息**：第一条消息自动使用新会话，避免继承问题会话

### 3.3 工具栏功能
- **新会话按钮**：开始新的对话会话
- **清空按钮**：清空当前显示的所有消息
- **日志按钮**：显示当前会话的日志文件位置
- **导出按钮**：将对话导出为 Markdown 文件
- **显示工具调用复选框**：控制是否显示工具调用信息

### 3.4 状态栏功能
- **会话ID显示**：显示当前会话的唯一标识
- **消息计数**：显示当前会话中的消息数量
- **连接状态**：显示与 Claude SDK 的连接状态（可选）

## 4. 内联引用系统

### 4.1 引用触发机制
- **触发符号**：`@`
- **触发条件**：
  - `@` 前面是空格、换行或字符串开头
  - `@` 后面不是已有的引用格式（如 `file://`、`https://` 等）
  - 避免在现有引用中重复触发
  - 例如：`请查看 @MainActivity.kt 文件`

### 4.2 上下文选择器
- **显示控制**：仅在满足触发条件时显示，避免自动弹出
- **选择后关闭**：选择文件或网页后立即关闭选择器
- **搜索功能**：项目内文件搜索和网页URL输入
- **搜索策略**：
  1. 精确文件名匹配（优先级最高）
  2. 文件名包含搜索词
  3. 路径包含搜索词
- **结果限制**：最多显示 30 个结果

### 4.3 可扩展引用格式系统

#### 当前支持的引用类型
| 类型 | 格式 | 显示 | 描述 |
|------|------|------|------|
| 文件 | `@file://src/main.kt` | `@main.kt` | 本地文件引用 |
| HTTP | `@http://example.com/page` | `@example.com` | HTTP网页链接 |
| HTTPS | `@https://example.com/page` | `@example.com` | HTTPS网页链接 |
| Git | `@git://github.com/user/repo.git` | `@repo` | Git仓库引用 |
| 符号 | `@symbol://MyClass.method` | `@method` | 代码符号引用 |
| 终端 | `@terminal://command` | `@terminal` | 终端命令引用 |
| 工作区 | `@workspace://` | `@workspace` | 工作区引用 |

#### 扩展机制
- 基于枚举的可扩展架构
- 自动生成正则表达式匹配模式
- 类型安全的验证系统
- 集中化的显示规则管理

### 4.4 数据流和存储

#### 三种格式的一致性
1. **用户输入**：通过上下文选择器生成 `@file://src/main.kt`
2. **存储格式**：会话历史保存 `@file://src/main.kt`（原始格式）
3. **发送给AI**：直接发送 `@file://src/main.kt`（无转换）
4. **UI显示**：渲染为 `@main.kt`（超链接样式）

#### 历史会话兼容性
- 重新加载会话时，`@file://` 格式能正确识别
- 保持数据一致性，避免格式转换带来的信息丢失
- Claude能理解标准的 `@file://` 格式引用

### 4.5 富文本显示机制

#### 核心原理
- **底层数据**：始终保持 `@file://path/to/file.kt` 格式
- **显示渲染**：识别 `@file://` 模式，渲染为超链接样式的 `@file.kt`
- **实时转换**：输入框和消息显示区域都进行实时渲染转换

#### 输入框中的显示
- **用户输入**：`@` → 选择文件 → 插入 `@file://src/main.kt`
- **实时渲染**：立即显示为蓝色超链接 `@main.kt`
- **光标编辑**：支持在超链接前后正常编辑
- **整体删除**：退格键可整体删除一个文件引用

#### 消息显示区域
- **用户消息**：识别并渲染 `@file://` 格式为超链接
- **AI回复**：如果AI回复包含 `@file://` 格式，同样渲染
- **一致体验**：输入框和消息区域的显示效果完全一致

#### 样式规范
- **颜色**：蓝色 (`#007ACC`)
- **装饰**：整体作为一个单元显示
- **字重**：正常字重
- **交互**：可点击打开文件，悬停显示完整路径

#### 技术要求
- **性能**：渲染转换需要高效，避免输入卡顿
- **准确性**：正确识别引用边界，避免误识别
- **可扩展**：支持未来添加更多引用类型

### 4.6 标签上下文 vs 内联引用

#### 两种引用方式
1. **标签上下文**（Add Context 按钮或 ⌘K 快捷键）
   - 显示为可移除的标签
   - 在消息头部显示
   - 发送时构建为上下文资料格式

2. **内联引用**（@ 符号触发）
   - 嵌入在消息文本中
   - 显示为超链接样式
   - 发送时保持原始格式

#### 区分原则
- 标签上下文：用于为整个对话提供背景资料
- 内联引用：用于在消息中直接引用特定文件或资源

### 4.7 问题修复记录

#### 已解决的关键问题
1. **上下文选择器自动弹出问题**
   - **问题**：应用启动时上下文选择器立即显示且无法关闭
   - **原因**：`ChatInputContextSelectorPopup` 组件 `visible` 属性硬编码为 `true`
   - **解决方案**：添加 `showContextSelector` 状态控制，仅在真正需要时显示

2. **@符号重复触发问题**
   - **问题**：在已有的引用格式中输入会重复触发上下文选择
   - **原因**：检测逻辑只检查 `@` 符号，未考虑后续内容
   - **解决方案**：使用可扩展的检测系统，检测现有引用格式

3. **引用格式扩展困难**
   - **问题**：硬编码的正则表达式难以维护和扩展
   - **原因**：分散的检测逻辑和手写的正则表达式
   - **解决方案**：基于枚举的可扩展架构，自动生成匹配模式

#### 技术改进
- 实现了状态驱动的组件显示控制
- 建立了可扩展的引用类型系统
- 确保了数据格式的一致性和向后兼容性
- 提供了类型安全的验证机制

## 5. 主题适配需求

### 5.1 颜色方案
- **自动适配**：根据 IDE 当前主题（Light/Dark）自动调整颜色
- **用户消息背景**：
  - Light 主题：浅灰色 (#F5F5F5 或 UIManager 的 TextField.background)
  - Dark 主题：深灰色 (#2B2B2B 或 UIManager 的 TextField.background)
- **对话区域背景**：使用 Editor.background
- **文本颜色**：使用 Editor.foreground
- **边框颜色**：使用 Component.borderColor

### 5.2 获取主题信息
- 使用 `UIUtil.isUnderDarcula()` 判断是否为深色主题
- 使用 `UIManager.getColor()` 获取主题颜色
- 监听主题变化并实时更新界面

## 6. Markdown 渲染需求

### 6.1 支持的 Markdown 特性
- 标题（# ## ### 等）
- 粗体、斜体、删除线
- 代码块（支持语法高亮）
- 行内代码
- 列表（有序和无序）
- 引用块
- 表格
- 链接
- 图片（如果支持）

### 5.2 代码块渲染
```kotlin
// 代码块应该有语法高亮
fun main() {
    println("Hello World")
}
```

### 6.3 自定义样式
- 字体：系统默认字体
- 代码块背景：根据主题自适应
- 代码块内边距：10px
- 链接颜色：IDE 主题的链接颜色

## 6. 交互细节

### 6.1 输入框设计（ChatInputArea 组件）

#### 布局结构
```
┌─ 统一边框 ────────────────────────────────────────────┐
│ 📎 Add Context [上下文标签1] [上下文标签2] ...         │
│ ────────────────────────────────────────────────    │
│ 输入消息，使用 @ 内联引用文件，或 ⌘K 添加上下文...      │
│                                                    │
│ ────────────────────────────────────────────────    │
│ Claude 4 Opus ▼                              ↑    │
└────────────────────────────────────────────────────┘
```

#### 组件封装要求
- **统一组件**：所有输入相关功能封装在 `ChatInputArea` 组件中
- **功能完整性**：包含输入框、发送按钮、模型选择器、上下文选择等所有功能
- **避免功能丢失**：组件化后确保不会再出现按钮消失等问题

#### 视觉设计规范
- **统一边框**：整个输入区域使用一个统一的边框
- **无内嵌边框**：输入框内部不使用嵌套边框，保持简洁
- **同背景设计**：Add Context 按钮与输入框使用相同背景色
- **紧凑布局**：组件间距紧凑，提高空间利用率

#### 第一行布局（上下文行）
- **Add Context 按钮**：
  - 位置：行首
  - 背景：与整体输入框相同背景色（`JewelTheme.globalColors.panelBackground`）
  - 圆角：4dp
  - 高度：24dp
  - 字体大小：10sp
  - 内边距：horizontal 6dp, vertical 2dp
  - 点击行为：触发上下文选择器
- **上下文标签**：
  - 位置：Add Context 按钮右侧
  - 显示：水平滚动列表（LazyRow）
  - 间距：4dp
  - 支持删除操作
- **提示文字**：已移除，保持界面简洁

#### 输入框区域
- **多行支持**：最小高度 32dp，最大高度 120dp
- **占位符文本**："输入消息，使用 @ 内联引用文件，或 ⌘K 添加上下文..."
- **字体大小**：14sp
- **内边距**：4dp
- **无边框**：输入框本身无边框，依赖外层统一边框

#### 底部控制栏
- **左侧**：模型选择器
  - 样式：小巧无背景设计
  - 高度：24dp
  - 字体大小：9sp
  - 下拉箭头：7sp
  - 透明背景，与主题融合
- **右侧**：发送/停止按钮
  - 尺寸：24dp × 24dp
  - 图标大小：10sp
  - 状态切换：发送（↑）/ 停止（⏹）
  - 智能启用：根据输入内容和生成状态

#### 功能特性
- **快捷键支持**：
  - Enter：发送消息
  - Shift+Enter：换行
  - @：触发内联文件引用
  - ⌘K：触发上下文选择器
  - ESC：关闭上下文选择器
- **上下文管理**：
  - 三种添加方式：按钮点击、@符号、⌘K快捷键
  - 标签式显示：可视化上下文列表
  - 内联引用：@符号直接在文本中插入文件引用
- **状态管理**：
  - 生成中禁用输入和模型选择
  - 智能按钮切换（发送/停止）
  - 实时同步外部状态

#### 交互设计原则
- **Cursor 风格**：参考 Cursor 编辑器的设计理念
- **现代化体验**：符合主流聊天应用的交互习惯
- **键盘友好**：支持完整的键盘操作
- **响应式设计**：组件状态实时响应用户操作

### 6.2 消息发送流程
1. 用户输入消息
2. 选择模型（可选，默认为 Opus）
3. 按 Enter 发送（无需点击按钮）
4. 立即在界面显示用户消息
5. 输入框清空，恢复占位符文本
6. 显示 Claude 正在输入的指示
7. 流式显示 Claude 的回复（包括工具调用）
8. 回复完成后输入框保持可用状态

### 6.3 模型选择逻辑
- **Claude 4 Opus**：传递参数 "opus"，由服务端映射到具体模型
- **Claude 4 Sonnet**：传递参数 "sonnet"，由服务端映射到具体模型# 上下文消息格式设计文档

## 概述

本文档详细说明 Claude Code Plus 中上下文消息格式的设计理念、实现方案和使用方式。

## 背景和需求

### 问题描述

在原始设计中，存在两种不同的上下文添加方式：
1. **Add Context 按钮**：添加的上下文显示为输入框上方的标签
2. **@ 符号触发**：添加的上下文内联显示在输入框文本中

根据用户反馈，现在采用以下区分方式：
- **Add Context 按钮**：添加的上下文创建标签并在消息开头以 Markdown 引用块格式显示
- **@ 符号触发**：添加的上下文仅内联插入到输入框文本中，不创建标签，格式如 `@filename.ext`

### 解决方案

提供两种不同的引用体验：
- **正式上下文**：通过 Add Context 按钮添加，显示为标签，在消息头部以引用块格式显示
- **快速引用**：通过 @ 符号添加，仅在消息文本中显示，不创建标签或在消息头部显示
- **智能显示**：@ 符号引用在消息中显示简短文件名，但发送时包含完整路径信息
- **混合使用**：支持在同一消息中混合使用两种方式
- **用户控制**：用户可以根据需要选择合适的引用方式

## 技术实现

### INLINE 类型上下文设计

#### 需求分析

对于 @ 符号触发的上下文引用，我们需要实现：
1. **用户友好的显示**：在消息中显示简短的文件名，如 `@ContextSelectorTestApp.kt`
2. **完整的路径信息**：发送时包含完整路径信息，确保 AI 能准确定位文件
3. **无标签管理**：不创建上下文标签，保持输入区域简洁
4. **智能解析**：支持从显示文本中提取完整路径信息

#### 实现方案

##### 1. 显示与存储分离

```kotlin
data class InlineFileReference(
    val displayName: String,    // 显示名称：ContextSelectorTestApp.kt
    val fullPath: String,       // 完整路径：desktop/src/main/kotlin/com/claudecodeplus/test/ContextSelectorTestApp.kt
    val relativePath: String    // 相对路径：src/main/kotlin/com/claudecodeplus/test/ContextSelectorTestApp.kt
)
```

##### 2. 消息构建流程

```
输入: @Context...
  ↓
选择文件: /full/path/to/ContextSelectorTestApp.kt
  ↓
插入文本: @ContextSelectorTestApp.kt
  ↓
存储映射: @ContextSelectorTestApp.kt → /full/path/to/ContextSelectorTestApp.kt
  ↓
发送时展开: @/full/path/to/ContextSelectorTestApp.kt
```

##### 3. 文本处理

```kotlin
// 消息发送前的路径展开
fun expandInlineReferences(message: String, referenceMap: Map<String, String>): String {
    val pattern = "@([\\w.-]+)".toRegex()
    return pattern.replace(message) { matchResult ->
        val displayName = matchResult.groupValues[1]
        val fullPath = referenceMap["@$displayName"]
        if (fullPath != null) "@$fullPath" else matchResult.value
    }
}
```

### 数据模型

#### ContextReference 基类

```kotlin
sealed class ContextReference {
    abstract val displayType: ContextDisplayType
}

enum class ContextDisplayType {
    TAG,     // 显示为标签，在消息头部以引用块格式显示
    INLINE   // 仅内联显示在消息文本中，不创建标签，格式如 @filename.ext
}
```

#### 具体类型

```kotlin
data class FileReference(
    val path: String,
    val fullPath: String = path,
    override val displayType: ContextDisplayType = ContextDisplayType.TAG
) : ContextReference()

data class WebReference(
    val url: String,
    val title: String? = null,
    override val displayType: ContextDisplayType = ContextDisplayType.TAG
) : ContextReference()

// ... 其他类型
```

### UI 组件实现

#### 布局结构

```
输入容器
├── 工具栏行
│   ├── Add Context 按钮 (左侧)
│   └── 上下文标签列表 (右侧，水平滚动)
└── 输入框区域
```

#### 关键代码

```kotlin
// 顶部工具栏：Add Context按钮（左）+ 上下文标签（右）
Row(
    modifier = Modifier.fillMaxWidth(),
    horizontalArrangement = Arrangement.SpaceBetween,
    verticalAlignment = Alignment.CenterVertically
) {
    // Add Context 按钮
    AddContextButton(
        onClick = { showContextSelector = true }
    )
    
    // 上下文标签显示 - 在同一行右侧
    if (contexts.isNotEmpty()) {
        LazyRow(
            horizontalArrangement = Arrangement.spacedBy(4.dp),
            modifier = Modifier.weight(1f)
        ) {
            items(contexts) { context ->
                ContextTag(
                    context = context,
                    onRemove = { onContextRemove(context) }
                )
            }
        }
    }
}
```

### 消息构建

#### buildFinalMessage 函数

```kotlin
private fun buildFinalMessage(contexts: List<ContextReference>, userMessage: String): String {
    // 所有的上下文都是TAG类型（Add Context按钮添加的）
    // @符号添加的上下文不会进入contexts列表，直接在userMessage中
    
    if (contexts.isEmpty()) {
        return userMessage
    }
    
    val contextSection = buildString {
        appendLine("> **上下文资料**")
        appendLine("> ")
        
        contexts.forEach { context ->
            val contextLine = when (context) {
                is ContextReference.FileReference -> {
                    "> - 📄 `${context.path}`"
                }
                is ContextReference.WebReference -> {
                    val title = context.title?.let { " ($it)" } ?: ""
                    "> - 🌐 ${context.url}$title"
                }
                // ... 其他类型处理
            }
            appendLine(contextLine)
        }
        
        appendLine()
    }
    
    return contextSection + userMessage
}
```

## 消息格式规范

### Markdown 格式

```markdown
> **上下文资料**
> 
> - 📄 `src/main/kotlin/Main.kt`
> - 🌐 https://example.com (网页标题)
> - 📁 `src/main` (25个文件)

用户的实际消息内容...
```

### 图标规范

| 上下文类型 | 图标 | 说明 |
|-----------|------|------|
| FileReference | 📄 | 文件 |
| WebReference | 🌐 | 网页 |
| FolderReference | 📁 | 文件夹 |
| SymbolReference | 🔗 | 代码符号 |
| TerminalReference | 💻 | 终端输出 |
| ProblemsReference | ⚠️ | 问题报告 |
| GitReference | 🔀 | Git 操作 |
| SelectionReference | ✏️ | 选择内容 |
| WorkspaceReference | 🏠 | 工作区 |

### 格式化规则

1. **统一前缀**：所有上下文行都以 `> - ` 开头
2. **图标使用**：每种类型使用固定的 emoji 图标
3. **信息层次**：主要信息在前，补充信息在括号中
4. **文件路径**：使用反引号包围，提高可读性

## 使用场景

### 场景1：代码分析

```markdown
> **上下文资料**
> 
> - 📄 `build.gradle.kts`
> - 📄 `src/main/kotlin/Main.kt`
> - 📄 `src/main/kotlin/service/UserService.kt`

请分析这个项目的架构设计，重点关注依赖管理和服务层的实现。
```

### 场景2：问题排查

```markdown
> **上下文资料**
> 
> - 💻 终端输出 (150行) ⚠️
> - ⚠️ 问题报告 (5个) [ERROR]
> - 📄 `application.properties`

应用启动失败，请帮我分析错误原因并提供解决方案。
```

### 场景3：功能开发

```markdown
> **上下文资料**
> 
> - 🌐 https://docs.spring.io/spring-boot/docs/current/reference/html/web.html (Spring Boot Web)
> - 📁 `src/main/kotlin/controller` (8个文件)
> - 🔗 `UserController.createUser()` (FUNCTION) - UserController.kt:45

需要在现有的用户管理系统中添加批量导入功能，参考 Spring Boot 文档和现有的控制器实现。
```

### 场景4：混合使用

```markdown
> **上下文资料**
> 
> - 📄 `build.gradle.kts`
> - 📄 `src/main/resources/application.yml`

请帮我分析 @UserService.kt 和 @DatabaseConfig.kt 中的配置是否一致，特别是数据库连接相关的设置。
```

**显示效果**：
- 用户看到：`@UserService.kt` 和 `@DatabaseConfig.kt`
- 实际发送：`@src/main/kotlin/service/UserService.kt` 和 `@src/main/kotlin/config/DatabaseConfig.kt`

在这个例子中：
- `build.gradle.kts` 和 `application.yml` 是通过 Add Context 按钮添加的（显示为标签，在消息头部）
- `@UserService.kt` 和 `@DatabaseConfig.kt` 是通过@符号输入的（显示简短文件名，发送完整路径）

## 优势和特点

### 1. 用户体验统一
- 所有上下文都以相同方式显示和管理
- 避免了混合显示方式的困惑
- 符合 Cursor 等主流工具的交互模式

### 2. 技术实现简洁
- 统一的数据流处理
- 简化的组件状态管理
- 减少了条件判断逻辑

### 3. 日志和调试友好
- 清晰的格式标记：`> **上下文资料**`
- 易于正则表达式解析
- 便于统计和分析

### 4. Markdown 原生支持
- 引用块在各种 Markdown 渲染器中都能正确显示
- 保持良好的可读性
- 支持语法高亮和格式化

### 5. 可扩展性强
- 新的上下文类型只需添加对应的图标和格式化规则
- 支持复杂的上下文信息展示
- 便于未来功能扩展

## 解析和处理

### 正则表达式

```regex
^> \*\*上下文资料\*\*\n(?:> \n)?((?:> - .+\n)+)\n
```

### 解析示例 (JavaScript)

```javascript
function parseContextMessage(message) {
    const contextRegex = /^> \*\*上下文资料\*\*\n(?:> \n)?((?:> - .+\n)+)\n/;
    const match = message.match(contextRegex);
    
    if (!match) {
        return {
            hasContext: false,
            contexts: [],
            userMessage: message
        };
    }
    
    const contextSection = match[1];
    const contextLines = contextSection
        .split('\n')
        .filter(line => line.startsWith('> - '))
        .map(line => line.substring(4)); // 移除 "> - " 前缀
    
    const userMessage = message.substring(match[0].length);
    
    return {
        hasContext: true,
        contexts: contextLines,
        userMessage: userMessage
    };
}
```

### 使用示例

```javascript
const message = `> **上下文资料**
> 
> - 📄 \`Main.kt\`
> - 🌐 https://example.com

请分析这个文件`;

const parsed = parseContextMessage(message);
console.log(parsed);
// {
//   hasContext: true,
//   contexts: ['📄 `Main.kt`', '🌐 https://example.com'],
//   userMessage: '请分析这个文件'
// }
```

## 最佳实践

### 1. 上下文选择
- 优先选择最相关的文件和资源
- 避免添加过多上下文，影响 AI 处理效率
- 根据问题类型选择合适的上下文类型

### 2. 文件路径显示
- 优先显示相对路径，提高可读性
- 对于深层嵌套，可以显示关键路径部分
- 在悬停提示中显示完整路径

### 3. 错误处理
- 对于无效的上下文引用，显示警告标记
- 提供移除失效上下文的快捷操作
- 在发送前验证上下文的有效性

### 4. 性能优化
- 使用 LazyRow 支持大量上下文标签
- 实现上下文预览和延迟加载
- 合理控制上下文数量的上限

## 未来扩展

### 1. 智能上下文推荐
- 基于当前对话内容推荐相关文件
- 学习用户的上下文使用习惯
- 自动检测代码中的依赖关系

### 2. 上下文分组
- 支持将相关上下文分组管理
- 一键添加常用的上下文组合
- 项目级别的上下文模板

### 3. 高级格式化
- 支持上下文的自定义显示名称
- 添加上下文的优先级标记
- 支持条件性上下文（根据模型选择）

### 4. 导出和分享
- 导出包含上下文的对话记录
- 分享上下文配置给团队成员
- 上下文使用情况的统计报告

## 实现状态

### ✅ 已完成功能

#### 1. 核心数据模型
- [x] `InlineFileReference` 数据类
- [x] `InlineReferenceManager` 管理器
- [x] 路径展开和映射功能

#### 2. UI 组件集成
- [x] `EnhancedSmartInputArea` 支持内联引用
- [x] `JewelChatApp` 主聊天应用集成
- [x] `JewelChatPanel` Swing 包装器集成
- [x] `JewelConversationView` 对话视图集成

#### 3. 消息处理流程
- [x] 显示与发送分离逻辑
- [x] 自动路径展开功能
- [x] 发送后自动清理机制

#### 4. 测试和验证
- [x] 多功能测试环境
- [x] 聊天功能完整性验证
- [x] 上下文功能专项测试

### 🎯 功能特点

#### 智能显示
- **用户友好**：显示简短文件名如 `@ContextSelectorTestApp.kt`
- **技术完整**：发送完整路径如 `@src/main/kotlin/com/claudecodeplus/test/ContextSelectorTestApp.kt`
- **无感知切换**：用户体验流畅，技术处理透明

#### 双重上下文支持
- **正式上下文**：Add Context 按钮 → 标签显示 → 消息头部引用块
- **快速引用**：@ 符号触发 → 内联显示 → 仅在消息文本中

#### 完整集成
- **toolwindow 主模块**：所有功能完全集成
- **IntelliJ IDEA 插件**：可直接使用新功能
- **向后兼容**：保持所有原有功能

### 📋 使用指南

#### 开发者使用
```kotlin
// 创建内联引用管理器
val inlineReferenceManager = InlineReferenceManager()

// 添加到组件
EnhancedSmartInputArea(
    // ... 其他参数
    inlineReferenceManager = inlineReferenceManager
)

// 发送时展开引用
val expandedMessage = inlineReferenceManager.expandInlineReferences(userMessage)
```

#### 用户使用
1. **正式上下文**：点击 📎 Add Context → 选择文件 → 显示为标签
2. **快速引用**：输入 `@` → 选择文件 → 插入 `@filename.ext`

### 🔄 版本更新

#### v1.0.0 - 基础上下文功能
- TAG 类型上下文支持
- 基础消息格式

#### v1.1.0 - 内联引用功能
- INLINE 类型上下文支持
- 内联引用管理器
- 智能路径展开
- 双重上下文支持

## 总结

通过智能的上下文消息格式设计，我们实现了：

1. **用户体验优化**：简短显示 + 完整路径的最佳平衡
2. **功能灵活性**：正式上下文 + 快速引用的双重选择
3. **技术架构清晰**：组件解耦，数据流简洁
4. **开发友好**：易于扩展，便于维护

这种设计为 Claude Code Plus 提供了一个现代化、智能化的上下文管理系统，大大提升了用户的编程体验。 # 上下文选择功能需求文档

## 功能概述

实现类似 Cursor 的上下文选择功能，支持文件和Web URL的智能选择，提供直观的两步式选择流程和紧凑的展示界面。

## 详细需求

### 1. 触发机制

#### 1.1 基本触发条件
- **触发符号**：输入 `@` 字符
- **位置要求**：`@` 符号前后没有其他字符（独立存在）
- **触发时机**：实时检测，无需额外按键

#### 1.2 触发示例
```
✅ 正确触发：
- "请帮我分析 @ 这个文件"
- "@ 参考这个网页"
- 输入框开头直接输入 "@"

❌ 不会触发：
- "test@example.com"（邮箱格式）
- "user@domain"（用户名格式）
- "@github"（紧贴字符）
```

### 2. 上下文类型

#### 2.1 支持的类型
1. **File** - 文件选择
   - 图标：📁 或文件类型图标
   - 描述：项目文件、源代码、文档等
   
2. **Web** - 网页URL
   - 图标：🌐 或链接图标
   - 描述：网页链接、API文档、在线资源等

#### 2.2 未来扩展类型（预留）
3. **Terminal** - 终端输出
4. **Git** - Git相关信息
5. **Symbol** - 代码符号
6. **Selection** - 选中的代码
7. **Workspace** - 工作区信息

### 3. 两步式选择流程

#### 3.1 第一步：选择上下文类型
- **展示位置**：`@` 符号正下方弹出
- **展示内容**：
  ```
  📁 File     选择项目文件
  🌐 Web      输入网页链接
  ```
- **交互方式**：
  - 鼠标点击选择
  - 键盘上下箭头 + Enter选择
  - 直接输入字符默认进入文件选择

#### 3.2 第二步：选择具体上下文

##### 文件选择模式
- **初始展示**：显示项目根目录文件列表
- **搜索功能**：继续输入字符进行实时过滤
- **显示格式**：
  ```
  📄 Main.kt                     /src/main/kotlin/Main.kt
  📁 components/                 /src/main/kotlin/components/
  📄 README.md                   /README.md
  ```
- **文件信息**：
  - 主显示：文件名（粗体）
  - 副显示：相对路径（灰色、小字体）
  - 悬停提示：完整绝对路径

##### Web URL模式
- **输入提示**：显示输入框 "请输入网页URL..."
- **验证功能**：实时验证URL格式
- **支持协议**：http://, https://, file://
- **示例展示**：显示常用格式示例

### 4. UI设计规范

#### 4.1 弹出器位置
- **锚点**：`@` 符号位置
- **方向**：优先向下弹出，空间不足时向上
- **偏移**：水平居中对齐 `@` 符号

#### 4.2 主题适配
- **背景色**：`JewelTheme.globalColors.panelBackground`
- **边框**：1px，`JewelTheme.globalColors.borders.normal`
- **文字色**：`JewelTheme.globalColors.text.normal`
- **选中高亮**：`JewelTheme.globalColors.borders.focused`（15%透明度）

#### 4.3 尺寸规范
- **弹出器宽度**：300dp（固定）
- **最大高度**：400dp（超出显示滚动条）
- **圆角**：4dp
- **内边距**：8dp
- **行高**：32dp

#### 4.4 动画效果
- **出现动画**：淡入 + 轻微缩放（150ms）
- **消失动画**：淡出（100ms）
- **选中动画**：背景色渐变（200ms）

### 5. 文件索引与搜索

#### 5.1 索引范围
- **包含**：所有项目文件（源码、配置、文档）
- **排除**：
  - `.git/` 目录
  - `node_modules/` 目录
  - 编译产物目录（`build/`, `target/`, `dist/`）
  - IDE配置文件（`.idea/`, `.vscode/`）

#### 5.2 搜索算法
- **模糊搜索**：支持部分匹配
- **权重排序**：
  1. 文件名完全匹配（权重：100）
  2. 文件名前缀匹配（权重：80）
  3. 文件名包含匹配（权重：60）
  4. 路径包含匹配（权重：40）
- **最大结果**：50个文件（性能考虑）

#### 5.3 文件类型图标
```kotlin
fun getFileIcon(fileName: String): String {
    return when (fileName.substringAfterLast('.').lowercase()) {
        "kt" -> "🔷"
        "java" -> "☕"
        "js", "ts" -> "💛"
        "py" -> "🐍"
        "md" -> "📝"
        "json" -> "📋"
        "xml" -> "🔖"
        "yml", "yaml" -> "⚙️"
        else -> "📄"
    }
}
```

### 6. 交互行为

#### 6.1 键盘操作
- **↑/↓箭头键**：在列表中上下导航选择项
  - 自动循环：到达边界时停留在第一项/最后一项
  - 平滑滚动：选中项自动滚动到可见区域
  - 视觉反馈：选中项高亮显示
- **Enter键**：确认选择当前高亮项
  - 文件选择：立即选择当前文件并关闭选择器
  - 类型选择：进入对应的选择模式
- **Esc键**：取消操作并关闭弹出器
  - 搜索框有内容时：清空搜索内容
  - 搜索框为空时：关闭整个选择器
- **PageUp/PageDown键**：快速翻页导航
  - PageUp：向上跳转5项
  - PageDown：向下跳转5项
- **Home/End键**：快速定位
  - Home：跳转到列表第一项
  - End：跳转到列表最后一项
- **字符输入**：实时过滤搜索
  - 文件模式：按文件名/路径过滤
  - Web模式：URL输入验证
  - 去抖动：300ms延迟，避免频繁搜索

#### 6.2 鼠标操作
- **点击选择项**：选择并更新选中状态
- **悬停显示**：显示文件完整路径或详细信息
- **点击外部区域**：关闭弹出器
- **滚轮滚动**：在长列表中导航

#### 6.3 组合操作
- **键盘导航 + 鼠标点击**：无缝切换操作方式
- **搜索过滤 + 键盘选择**：过滤后保持键盘导航
- **快速选择模式**：
  - 输入@后直接输入字符 → 自动进入文件搜索
  - 输入@后按下键盘 → 显示类型选择器

#### 6.4 上下文标签显示
- **文件标签格式**：选择后在输入框上方显示 `@filename` 标签
- **Web标签格式**：直接显示 `@http://` 或 `@https://` + 完整URL
- **背景样式**：使用与输入框相同的背景颜色进行区分
- **文件悬停提示**：显示完整路径（从 `@file://` 格式中提取）
- **Web悬停提示**：显示网页标题或其他元信息
- **路径支持**：自动识别和显示绝对路径或相对路径
- **删除功能**：标签右侧显示 `×` 按钮，点击移除上下文

### 7. 实现技术规范

#### 7.1 核心组件
1. **ContextSelectorPopup** - 主弹出器容器
2. **ContextTypeSelector** - 类型选择器
3. **FileContextSelector** - 文件选择器
4. **WebContextSelector** - Web URL选择器
5. **ContextItem** - 选择项组件

#### 7.2 数据模型
```kotlin
sealed class ContextType {
    object File : ContextType()
    object Web : ContextType()
}

data class FileContextItem(
    val name: String,
    val relativePath: String,
    val absolutePath: String,
    val isDirectory: Boolean,
    val fileType: String
)

data class WebContextItem(
    val url: String,
    val title: String? = null,
    val description: String? = null
)
```

#### 7.3 服务接口
```kotlin
interface ContextSearchService {
    suspend fun searchFiles(query: String): List<FileContextItem>
    fun validateUrl(url: String): Boolean
}
```

### 8. 测试环境实现

#### 8.1 desktop 组件
- **MockFileIndexService**：模拟文件索引
- **SimpleFileSearchService**：基础文件搜索
- **TestContextProvider**：测试数据提供

#### 8.2 插件环境实现
- **IdeaFileIndexService**：使用 IntelliJ FileIndex API
- **IdeaContextSearchService**：集成 IDE 搜索功能
- **PsiContextProvider**：基于 PSI 的上下文提供

### 9. 性能要求

#### 9.1 响应时间
- **弹出显示**：< 50ms
- **搜索响应**：< 200ms
- **文件索引**：< 500ms（初始化）

#### 9.2 内存使用
- **文件索引缓存**：< 50MB
- **搜索结果缓存**：< 10MB
- **UI组件内存**：< 5MB

### 10. 可访问性

#### 10.1 键盘导航
- **Tab序列**：合理的焦点顺序
- **快捷键**：支持常用快捷键
- **屏幕阅读器**：正确的语义标记

#### 10.2 视觉辅助
- **高对比度**：支持高对比度主题
- **字体缩放**：响应系统字体设置
- **颜色区分**：不依赖颜色传达信息

### 11. 错误处理

#### 11.1 文件访问错误
- **权限不足**：显示友好提示
- **文件不存在**：从结果中移除
- **索引失败**：降级到基础搜索

#### 11.2 网络相关错误
- **URL格式错误**：实时提示用户
- **连接超时**：显示离线模式
- **DNS解析失败**：提供建议

### 12. 国际化支持

#### 12.1 文本资源
- **中文**：默认语言
- **英文**：备选语言
- **提示信息**：支持多语言切换

#### 12.2 文件路径
- **路径分隔符**：跨平台兼容
- **字符编码**：UTF-8支持
- **特殊字符**：正确处理和显示

## 实现进度

### ✅ 已完成

#### 核心数据模型和架构
- **ContextModels.kt** - 完整的数据模型定义
  - ContextType（文件、Web、未来扩展类型）
  - FileContextItem（文件信息模型）
  - WebContextItem（Web信息模型）  
  - ContextSelectionState（选择状态管理）
  - ContextSelectionResult（选择结果）
  - SearchWeight（搜索权重配置）
  - ContextSelectorConfig（配置参数）

#### 服务接口层
- **ContextSearchService.kt** - 搜索服务接口
  - 文件搜索（同步/异步）
  - URL验证和信息获取
  - 搜索权重计算
  - 文件排除规则

#### UI组件层
- **ContextSelectorPopup.kt** - 主弹出容器
  - 弹出器位置计算和管理
  - 状态路由和生命周期管理
  - @符号检测工具函数
  - 上下文引用字符串生成

- **ContextTypeSelector.kt** - 类型选择器
  - 两种上下文类型选择（File/Web）
  - 键盘导航支持（↑↓Enter Esc）
  - 选中状态高亮和动画
  - Jewel主题适配

- **FileContextSelector.kt** - 文件选择器
  - 实时搜索和去抖动
  - 搜索结果按权重排序
  - 文件类型图标显示
  - 紧凑的文件信息展示
  - 加载状态和空结果处理

- **WebContextSelector.kt** - Web选择器  
  - URL格式验证
  - 页面信息获取和预览
  - 输入提示和示例展示
  - 错误状态处理

#### 测试环境
- **MockContextSearchService.kt** - 模拟搜索服务
  - 完整的测试数据集
  - 真实的搜索算法模拟
  - 网络请求延迟模拟
  - 动态测试数据管理

- **ContextSelectorTestApp.kt** - 独立测试应用
  - 完整的交互测试环境
  - 实时状态调试显示
  - 选择结果历史记录
  - @符号触发检测验证

### 🔄 开发中

#### 插件集成
- **IdeaContextSearchService** - IntelliJ集成服务（待实现）
- **插件输入框集成** - 与EnhancedSmartInputArea集成（待实现）
- **真实文件索引** - 基于IntelliJ FileIndex API（待实现）

#### 高级功能
- **上下文预览** - 文件内容预览（待实现）
- **最近使用记录** - 选择历史管理（待实现）
- **快捷键支持** - 全局快捷键绑定（待实现）

### 📋 待实现

#### 性能优化
- **文件索引缓存** - 提升大项目搜索性能
- **虚拟滚动** - 处理大量搜索结果
- **搜索结果缓存** - 减少重复搜索

#### 用户体验
- **智能排序** - 基于使用频率的结果排序
- **模糊搜索** - 更智能的搜索匹配算法
- **自动补全** - 文件路径自动补全

#### 可访问性
- **屏幕阅读器** - 完整的无障碍支持
- **高对比度** - 高对比度主题适配
- **键盘导航** - 完整的键盘操作支持

### 技术特点

#### 架构设计
- **分层架构**：UI层、服务层、数据层清晰分离
- **依赖注入**：通过接口实现服务层解耦
- **状态管理**：使用Compose状态和密封类管理复杂状态
- **响应式设计**：基于Flow的实时搜索

#### UI设计原则
- **Jewel原生组件**：完全使用JetBrains Jewel设计系统
- **主题一致性**：自动适配IDE主题和配色
- **紧凑设计**：最小化界面占用，突出内容
- **直观交互**：类似Cursor的用户体验

#### 性能考虑
- **去抖动搜索**：200ms延迟避免频繁搜索
- **结果限制**：最多50个结果保证性能
- **异步处理**：所有IO操作都是异步的
- **内存管理**：合理的缓存策略和资源回收

### 下一步计划

1. **插件集成**：将上下文选择器集成到主输入框
2. **IntelliJ服务**：实现基于IDE的真实文件搜索
3. **用户测试**：在实际项目中测试和优化体验
4. **文档完善**：编写用户使用指南和开发文档
5. **性能优化**：针对大型项目进行性能调优 