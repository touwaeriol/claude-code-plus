# 简化内联文件引用系统设计

## 概述

基于用户需求，设计一个**极简化**的内联文件引用系统：
- 🎯 **仅支持文件**：只支持文件引用，无需选择文件/web类型
- 🔍 **即时搜索**：输入 `@` 后立即在上方悬浮显示匹配文件
- ⚡ **实时过滤**：继续输入关键字，实时过滤文件列表
- ⌨️ **键盘导航**：上下箭头选择，Enter 确认，Esc 取消
- 💫 **悬浮显示**：文件列表悬浮在 @ 符号上方，不阻挡输入

## 用户体验设计

### 交互流程

```
步骤1: 用户输入 "@"
┌─────────────────────────────┐  ← 悬浮在 @ 符号上方
│ 📄 CLAUDE.md                │
│ 📁 .claude/                 │  
│ 📄 .gitignore               │
│ 📁 .gradle/                 │
│ 📄 GEMINI.md                │
└─────────────────────────────┘
输入框: 我需要查看 @|

步骤2: 继续输入 "clau" 
┌─────────────────────────────┐  ← 悬浮在 @ 符号上方
│ 📄 CLAUDE.md                │  ← 选中
│ 📁 .claude/                 │
│ 📄 .claude/commands/pull.md │
│ 📁 .claude/rules/           │
└─────────────────────────────┘
输入框: 我需要查看 @clau|

步骤3: 按Enter选择
输入框: 我需要查看 @CLAUDE.md |  ← 引用已插入，光标继续
```

### 关键特性

1. **悬浮显示**：文件列表始终悬浮在 @ 符号正上方
2. **不中断输入**：用户可以继续输入，实时过滤结果  
3. **智能匹配**：文件名和路径的模糊匹配
4. **无二次选择**：直接显示文件列表，无需选择类型

### 2. 支持的引用类型优先级

| 优先级 | 类型 | 触发格式 | 显示效果 | 描述 |
|-------|------|----------|----------|------|
| 🥇 **P0** | 文件路径 | `@path/file` | `@path/file.ext` | 项目文件的相对路径引用 |
| 🥈 **P1** | 文件名 | `@filename` | `@filename.ext` | 通过文件名模糊搜索 |
| 🥉 **P2** | 网页链接 | `@https://...` | `@网页标题` | HTTP/HTTPS 链接引用 |
| P3 | 符号引用 | `@Class::method` | `@method` | 代码符号引用（未来）|

## 核心技术实现

### 1. 实时搜索机制

```kotlin
// 文件搜索核心逻辑
LaunchedEffect(textFieldValue.text, textFieldValue.selection.start) {
    val cursorPos = textFieldValue.selection.start
    val atResult = findAtSymbolWithQuery(textFieldValue.text, cursorPos)
    
    if (atResult != null) {
        val (atPos, query) = atResult
        
        // 防抖延迟150ms
        delay(150)
        
        // 执行搜索
        val results = fileIndexService.searchFiles(
            query = query,
            maxResults = 10
        )
        searchResults = results
    }
}
```

### 2. @ 符号检测算法

```kotlin
private fun findAtSymbolWithQuery(text: String, cursorPos: Int): Pair<Int, String>? {
    if (cursorPos <= 0) return null
    
    // 从光标位置向前搜索 @ 符号
    for (i in (cursorPos - 1) downTo 0) {
        when (text[i]) {
            '@' -> {
                // 检查 @ 前是否是空白或文本开头
                val isValidAtStart = i == 0 || text[i - 1].isWhitespace()
                if (isValidAtStart) {
                    val queryText = text.substring(i + 1, cursorPos)
                    // 验证查询文本不包含空白字符
                    if (!queryText.any { it.isWhitespace() }) {
                        return Pair(i, queryText)
                    }
                }
                return null
            }
            ' ', '\n', '\t' -> return null // 遇到空白停止
        }
    }
    return null
}
```

### 3. 键盘导航系统

```kotlin
// 键盘事件处理
val keyEventHandler: (KeyEvent) -> Boolean = { keyEvent ->
    when {
        keyEvent.key == Key.DirectionUp && keyEvent.type == KeyEventType.KeyDown -> {
            selectedIndex = (selectedIndex - 1).coerceAtLeast(0)
            true
        }
        keyEvent.key == Key.DirectionDown && keyEvent.type == KeyEventType.KeyDown -> {
            selectedIndex = (selectedIndex + 1).coerceAtMost(results.size - 1)
            true
        }
        keyEvent.key == Key.Enter && keyEvent.type == KeyEventType.KeyDown -> {
            if (selectedIndex in results.indices) {
                onItemSelected(results[selectedIndex])
            }
            true
        }
        keyEvent.key == Key.Escape && keyEvent.type == KeyEventType.KeyDown -> {
            onDismiss()
            true
        }
        else -> false
    }
}

## 用户体验流程

### 1. 基础文件引用流程

```
步骤1: 用户输入 "@"
┌─────────────────────────────┐
│ Message Claude...           │ ← 光标位置
│ 我需要查看 @|               │
└─────────────────────────────┘

步骤2: 继续输入 "rules/"
┌─────────────────────────────┐
│ 搜索: @rules/               │
├─────────────────────────────┤
│ 📁 rules/                   │  ← 选中
│    rules/                   │
│ 📄 rules.md                 │
│    docs/rules.md            │
└─────────────────────────────┘

步骤3: 继续输入 "qe"  
┌─────────────────────────────┐
│ 搜索: @rules/qe             │
├─────────────────────────────┤
│ 📄 qeweqw.md                │  ← 选中
│    rules/qeweqw.md          │
│ 📄 query.kt                 │
│    src/rules/query.kt       │
└─────────────────────────────┘

步骤4: 按Enter选择
┌─────────────────────────────┐
│ Message Claude...           │
│ 我需要查看 @rules/qeweqw.md| │ ← 引用已插入，光标在末尾
└─────────────────────────────┘
```

### 2. 搜索优先级算法

```kotlin
// 搜索权重计算
fun calculateSearchWeight(file: IndexedFileInfo, query: String): Int {
    val fileName = file.name.lowercase()
    val filePath = file.relativePath.lowercase()
    val queryLower = query.lowercase()
    
    return when {
        // 精确匹配 - 最高权重
        fileName == queryLower -> 100
        filePath == queryLower -> 95
        
        // 前缀匹配 - 高权重  
        fileName.startsWith(queryLower) -> 90
        filePath.startsWith(queryLower) -> 85
        
        // 路径包含匹配 - 中高权重
        filePath.contains("/$queryLower") -> 80
        filePath.contains(queryLower) -> 75
        
        // 文件名包含匹配 - 中等权重
        fileName.contains(queryLower) -> 70
        
        // 模糊匹配 - 低权重
        isSequentialMatch(fileName, queryLower) -> 60
        isSequentialMatch(filePath, queryLower) -> 55
        
        else -> 0
    }
}
```

## 组件架构设计

### 1. 核心组件关系

```
ChatInputField (主输入组件)
├── InlineFileReferenceHandler (内联引用处理器)
│   ├── findAtSymbolWithQuery() (@ 符号检测)
│   ├── InlineReferencePopup (弹出选择器)
│   └── InlineFileResultItem (结果项显示)
├── FileIndexService (文件索引服务)
│   ├── searchFiles() (文件搜索)
│   ├── getRecentFiles() (最近文件)
│   └── getFileContent() (文件内容)
└── SessionObject (会话状态)
    ├── inputTextFieldValue (输入文本状态)
    └── inlineReferenceState (内联引用状态)
```

### 2. 状态管理

```kotlin
// 内联引用状态
data class InlineReferenceState(
    val isActive: Boolean = false,          // 是否激活引用模式
    val atPosition: Int = -1,               // @ 符号位置
    val searchQuery: String = "",           // 搜索查询
    val selectedIndex: Int = 0,             // 选中项索引
    val searchResults: List<FileInfo> = emptyList() // 搜索结果
)

// 文件引用结果
data class InlineFileReferenceResult(
    val file: IndexedFileInfo,              // 选中的文件
    val replaceStart: Int,                  // 替换起始位置
    val replaceEnd: Int                     // 替换结束位置
)
```

## 性能优化策略

### 1. 搜索防抖
- 用户输入后延迟 150ms 再执行搜索
- 避免频繁的文件系统查询

### 2. 结果缓存
- 缓存最近搜索结果
- 相同查询直接返回缓存

### 3. 增量搜索
- 基于上次结果进行过滤
- 减少文件系统遍历

## 扩展性设计

### 1. 支持更多引用类型

```kotlin
// 未来扩展：符号引用
@Class::method -> 跳转到类方法
@variable -> 跳转到变量定义
@type -> 跳转到类型定义

// 未来扩展：外部引用  
@github:user/repo -> GitHub 仓库
@npm:package-name -> NPM 包
@doc:section -> 文档章节
```

### 2. 智能建议

```kotlin
// 基于上下文的智能建议
// 在 .kt 文件中输入 @，优先显示 Kotlin 相关文件
// 在 README 中输入 @，优先显示文档文件
// 基于最近使用频率排序
```

## 设计原则

1. **🎯 用户体验第一**：响应速度 < 300ms，操作流畅自然
2. **⚡ 性能优先**：搜索结果限制在 10 个以内，避免界面过载
3. **🔍 搜索精准**：智能权重算法，最相关的结果排在前面
4. **⌨️ 键盘友好**：全程支持键盘操作，无需鼠标
5. **🎨 视觉清晰**：文件类型图标、路径层级清晰显示
6. **🔧 易于扩展**：组件化设计，便于添加新的引用类型

## 技术要求

- ✅ 使用 Jetpack Compose + Jewel UI 组件
- ✅ 基于 FileIndexService 进行文件搜索
- ✅ 支持防抖、缓存等性能优化
- ✅ 完整的键盘导航支持
- ✅ 与现有会话系统无缝集成