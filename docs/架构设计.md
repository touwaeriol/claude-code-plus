# Claude Code Plus 架构说明

## 项目概述

Claude Code Plus 是一个跨平台的 AI 编程助手，提供两种使用方式：
1. **IntelliJ IDEA 插件** - 深度集成到 IDE 中
2. **独立桌面应用** - 基于 Compose Desktop 的跨平台应用

两种方式共享核心组件，通过 Node.js 桥接层调用官方 Claude Code SDK 来提供 AI 功能。

## 核心架构

### 1. 基于 Claude Code SDK

本插件采用官方 Claude Code SDK（@anthropic-ai/claude-code）的方式，通过 Node.js 桥接层提供服务。这种设计具有以下优势：

- **官方支持**：使用 Anthropic 官方维护的 SDK，确保兼容性和功能完整性
- **类型安全**：SDK 提供完整的类型定义和错误处理
- **功能丰富**：支持 SDK 的所有最新功能和特性
- **稳定可靠**：跟随官方版本更新，无需维护 CLI 参数映射

### 2. 工作原理

```
用户输入 -> IntelliJ 插件 -> ClaudeCliWrapper -> Node.js 桥接 -> Claude Code SDK -> Claude API
    ^                                                                                        |
    |<--------------------- 流式响应 <---------------------------------------------------|
```

## 核心组件

### ClaudeCliWrapper (`/cli-wrapper/src/main/kotlin/com/claudecodeplus/sdk/ClaudeCliWrapper.kt`)

这是与 Claude Code SDK 交互的核心组件，负责：

1. **Node.js 桥接管理**：启动和管理 Node.js 脚本进程
2. **参数映射**：将 QueryOptions 转换为 SDK 兼容的 JSON 格式
   - 支持所有 Claude Code SDK 选项
   - 自动处理权限和工具配置
   - MCP 服务器配置支持
3. **流式响应处理**：解析 Node.js 脚本返回的 JSON 消息
4. **会话管理**：处理会话 ID 和恢复功能（由 SDK 自动管理）
5. **错误处理**：捕获并处理 SDK 和进程错误
6. **中断支持**：通过 `terminate()` 方法终止 Node.js 进程

#### 关键实现细节：

```kotlin
// 获取 Node.js 脚本路径
private fun getNodeScriptPath(): String {
    // 支持多种部署场景的路径查找逻辑
    val possiblePaths = listOf(
        // 开发环境
        java.io.File(System.getProperty("user.dir"), "cli-wrapper/claude-sdk-wrapper.js"),
        // 打包环境
        getScriptFromResources(),
        // JAR 同级目录
        getScriptFromJarLocation()
    ).filterNotNull()
    
    return possiblePaths.firstOrNull { it.exists() }?.absolutePath
        ?: throw IllegalStateException("Node.js 脚本未找到")
}

// 构建 JSON 输入参数
val jsonInput = buildJsonObject {
    put("prompt", prompt)
    put("options", buildJsonObject {
        options.model?.let { put("model", it) }
        options.resume?.let { if (it.isNotBlank()) put("resume", it) }
        put("cwd", options.cwd)
        if (options.skipPermissions) put("skipPermissions", true)
        // ... 其他选项映射
    })
}.toString()

// 调用 Node.js 脚本
val nodeCommand = listOf("node", scriptPath, jsonInput)
```

### Node.js 桥接层 (`/cli-wrapper/claude-sdk-wrapper.js`)

这是连接 Kotlin 和 Claude Code SDK 的桥接层：

#### 主要功能：
1. **参数解析**：接收 Kotlin 传递的 JSON 参数
2. **SDK 集成**：使用 @anthropic-ai/claude-code SDK 执行查询
3. **消息转发**：将 SDK 返回的消息转换为统一格式输出
4. **错误处理**：处理 SDK 错误并转换为统一格式

#### 消息格式：
```javascript
// 开始消息
{"type": "start", "sessionId": "...", "processId": 12345, "timestamp": "..."}

// Claude 响应消息
{"type": "message", "data": {...}, "messageIndex": 1, "timestamp": "..."}

// 完成消息
{"type": "complete", "sessionId": "...", "messageCount": 5, "duration": 1500}

// 错误消息
{"type": "error", "error": "...", "stack": "...", "timestamp": "..."}
```

### 环境要求

#### Node.js 环境：
- **Node.js 18+**：必须安装并在 PATH 中可用
- **@anthropic-ai/claude-code**：通过 `npm install` 自动安装
- **ANTHROPIC_API_KEY**：必须设置环境变量

#### 部署支持：
- **开发环境**：脚本在 cli-wrapper 目录下
- **JAR 打包**：脚本和依赖打包在 JAR 中
- **跨平台**：支持 Windows、macOS、Linux

### UI 组件架构 (`/toolwindow/src/main/kotlin/com/claudecodeplus/ui/`)

基于 Compose 的现代化 UI 架构：

#### 核心 UI 组件：
- `JewelChatApp` - 主聊天应用组件
- `JewelChatPanel` - 聊天面板实现
- `ProjectTabBar` - 项目标签栏
- `SessionListPanel` - 会话列表面板
- `MultiTabChatView` - 多标签聊天视图（桌面版隐藏标签栏）

#### 服务层：
- `ProjectManager` - 项目管理服务
- `ChatTabManager` - 标签管理服务（后台运行）
- `SessionHistoryService` - 会话历史服务
- `SessionLoader` - 会话加载器，支持历史/实时两种模式
- `MessageProcessor` - 消息处理服务

#### 桌面应用特定组件：
- `Main.kt` - 桌面应用入口
- `ServiceContainer` - 依赖注入容器
- `DesktopProjectService` - 桌面项目服务实现
- `SimpleFileIndexService` - 简单文件索引服务

### 数据模型

#### SDK 数据模型 (`/cli-wrapper/src/main/kotlin/com/claudecodeplus/sdk/DataClasses.kt`)
定义了与 Claude CLI 交互的数据结构：
- `MessageType`：消息类型枚举
- `SDKMessage`：SDK 消息结构
- `MessageData`：消息数据内容

#### UI 数据模型 (`/toolwindow/src/main/kotlin/com/claudecodeplus/ui/models/`)
定义了 UI 层使用的数据结构：
- `UnifiedModels.kt` - 所有数据模型的集中定义
  - `EnhancedMessage` - 增强的消息模型，包含工具调用、上下文等
  - `ToolCall` - 工具调用模型，使用 `parameters` 代替 `input`
  - `ToolResult` - 工具结果的密封类（Success/Failure）
  - `MessageTimelineItem` - 有序元素（替代了 OrderedElement）
  - `AiModel` - AI 模型枚举，使用 `cliName` 属性
  - `PermissionMode` - 权限模式枚举，使用 `cliName` 属性
  - `ToolCallStatus` - 工具状态（PENDING/RUNNING/SUCCESS/FAILED/CANCELLED）
- `EnhancedMessage.kt` - 为向后兼容保留，仅包含重导出注释

## 会话管理架构

### Claude Code 会话机制
- **存储位置**: `~/.claude/projects/[encoded-project-path]/`
- **文件格式**: JSONL (JSON Lines)，每行一个 JSON 对象
- **文件命名**: UUID 格式，如 `161f9378-8799-4c13-b7fb-1287c5b7d627.jsonl`
- **会话命令**:
  - `claude`: 创建新会话
  - `claude -c`: 继续最近的会话
  - `claude -r [sessionId]`: 恢复指定会话

### Claude CLI 会话连续性机制 (重要发现)

基于对 Claudia 项目的深入分析和实际测试，我们确认了 Claude CLI 的会话行为：

#### `--resume` 参数在 `--print` 模式的行为
1. **每次调用都创建新会话文件**: 即使使用 `--resume sessionId`，Claude CLI 在 `--print` 模式下仍会创建新的会话文件
2. **会话 ID 会改变**: 每次调用都会生成新的 sessionId，而不是复用原始会话 ID
3. **内容连续性通过其他机制保持**: Claude 通过 `leafUuid` 链接和 `summary` 机制保持对话连续性

#### leafUuid 链接机制
```json
{
  "type": "summary", 
  "summary": "会话摘要内容",
  "leafUuid": "previous-session-leaf-uuid"
}
```
- **作用**: 新会话通过 `leafUuid` 引用前一个会话的终点
- **链接方式**: 第一个会话的 `leafUuid` 会在后续会话中被引用
- **连续性**: 即使 sessionId 不同，Claude 能通过这种机制保持上下文

#### 文件监听问题根本原因
- **传统文件监听失效**: 由于每次 `--resume` 都创建新文件，文件监听系统会监听错误的文件
- **消息显示断链**: 新消息写入新文件，但 UI 仍在监听旧文件，导致消息无法显示
- **解决方案**: 必须采用事件驱动架构，直接监听 Claude CLI 进程的 stdout/stderr

### 项目和会话的关系
- 每个项目可以包含多个会话
- 会话通过项目 ID 与项目关联
- 切换项目时自动加载该项目的会话列表

### 会话生命周期
1. **占位会话创建**：用户点击"新建会话"时创建占位会话（id为null）
2. **Claude 会话创建**：发送第一条消息时，Claude CLI 创建实际的会话并返回会话 ID
3. **会话 ID 映射**：占位会话的 null ID 更新为 Claude 返回的真实 ID
4. **会话持久化**：会话文件由 Claude CLI 管理，存储在 `~/.claude/projects/` 目录中

### 会话状态管理系统

#### 核心组件
1. **SessionObject** (`/toolwindow/src/main/kotlin/com/claudecodeplus/ui/models/SessionObject.kt`)
   - 会话的完整状态容器
   - 包含会话ID、消息列表、上下文、生成状态、配置等
   - 使用对象引用避免触发不必要的 LaunchedEffect

2. **SessionManager** (`/toolwindow/src/main/kotlin/com/claudecodeplus/ui/services/SessionManager.kt`)
   - 集中管理所有会话的生命周期
   - 使用 ConcurrentHashMap 支持并发访问
   - 支持多会话同时生成响应
   - 提供会话统计和查询功能

3. **DefaultSessionConfig** (`/toolwindow/src/main/kotlin/com/claudecodeplus/ui/services/DefaultSessionConfig.kt`)
   - 管理全局默认会话配置
   - 包括默认AI模型、权限模式、跳过权限设置
   - 配置持久化到用户设置

4. **SessionPersistenceService** (`/toolwindow/src/main/kotlin/com/claudecodeplus/ui/services/SessionPersistenceService.kt`)
   - 负责会话配置的持久化
   - 保存到项目的 `.claude/sessions` 目录
   - 支持会话切换时的配置保存和恢复

#### 会话配置管理
- **每个会话独立的配置**：
  - 选择的 AI 模型 (selectedModel)
  - 权限模式 (selectedPermissionMode)
  - 是否跳过权限确认 (skipPermissions)
  
- **配置继承机制**：
  - 新会话创建时从 DefaultSessionConfig 继承默认配置
  - 用户可以为每个会话自定义配置
  - 配置更改实时保存，确保重启后能恢复

#### 并发会话支持
- 每个会话有独立的生成状态 (isGenerating)
- 独立的协程任务管理 (currentStreamJob)
- 切换会话不会中断其他会话的生成
- 支持查看所有正在生成的会话列表

### 事件驱动架构方案 (基于 Claudia 分析)

#### Claudia 项目的成功模式
参考 Claudia 项目 (`claudia/src-tauri/src/commands/claude.rs`) 的实现：

1. **事件驱动系统**: 
   - 使用 Tauri 事件系统：`claude-output`, `claude-error`, `claude-complete`
   - 直接监听 Claude CLI 进程的 stdout/stderr 流
   - 避免文件系统监听的复杂性和延迟

2. **历史记录预加载**:
   ```rust
   // Claudia 在启动会话时预加载历史
   let history = api.loadSessionHistory(session.id, session.project_id);
   setMessages(loadedMessages);  // 先显示历史消息
   // 然后监听新消息流
   ```

3. **会话管理策略**:
   - **首次启动**: 调用 `execute_claude_code`（不使用 --resume）
   - **继续会话**: 调用 `resume_claude_code`（使用 --resume）
   - **历史加载**: 每次打开会话都先加载完整历史记录

#### 我们需要实现的事件驱动架构

```kotlin
// 新的事件驱动架构组件
class ClaudeProcessEventHandler {
    suspend fun executeWithEvents(
        command: List<String>,
        onOutput: (String) -> Unit,
        onError: (String) -> Unit,
        onComplete: (Boolean) -> Unit
    ): Process
}

// 替代当前的文件监听系统
class ClaudeEventService {
    fun startSession(projectPath: String, prompt: String): Flow<ClaudeEvent>
    fun resumeSession(sessionId: String, prompt: String): Flow<ClaudeEvent>
}
```

### 历史会话加载机制
SessionLoader 组件负责加载历史会话，支持两种模式：
- **历史模式（isHistoryMode=true）**：用于加载历史会话，不在END消息时清理状态，确保工具结果能正确关联
- **实时模式（isHistoryMode=false）**：用于实时消息处理，END消息会触发状态清理

#### Claude CLI 消息流顺序
1. START（用户/助手消息开始）
2. TEXT/TOOL_USE（内容块）
3. END（消息结束）
4. TOOL_RESULT（工具执行结果 - 可能在END之后）

这种设计解决了Claude CLI消息流中工具结果在END消息之后到达的问题。

### 会话数据结构
```json
{
  "sessionId": "UUID",          // 会话标识符
  "uuid": "UUID",               // 消息唯一标识
  "parentUuid": "UUID|null",    // 父消息ID（形成对话链）
  "type": "user|assistant",     // 消息类型
  "timestamp": "ISO8601",       // 时间戳
  "message": {                  // 消息内容
    "role": "user|assistant",
    "content": "...",
    "id": "msg_xxx",           // assistant 消息特有
    "model": "claude-xxx",     // assistant 消息特有
    "usage": {...}             // token 使用情况
  },
  "cwd": "/path/to/project",    // 工作目录
  "version": "1.0.38",          // Claude版本
  "isSidechain": false,         // 是否为侧链
  "userType": "external"        // 用户类型
}
```

### 标签管理（后台）
- 桌面应用隐藏了 MultiTabChatView 的标签栏
- ChatTabManager 仍在后台管理标签状态
- 每个会话对应一个隐藏的标签
- 通过会话列表选择会话，而非标签切换

## 配置和设置

### MCP (Model Context Protocol) 支持

支持 MCP 配置，允许用户扩展 Claude 的能力：

- **全局配置**：在插件设置中配置
- **项目配置**：在项目根目录的 `.claude/config.json` 中配置
- **配置合并**：项目配置会覆盖全局配置

## 测试

### 单元测试 (`/src/test/kotlin/com/claudecodeplus/sdk/ClaudeCliWrapperTest.kt`)

包含了对 ClaudeCliWrapper 的全面测试：

- 基本查询功能测试
- 错误处理测试
- 参数构建测试
- Claude CLI 可用性检查

运行测试：
```bash
# 运行所有测试
./gradlew test

# 运行包含实际 Claude API 调用的测试
RUN_CLAUDE_TESTS=true ./gradlew test
```

## Claude CLI 消息格式

### JSONL 消息类型
Claude CLI 使用 JSONL（JSON Lines）格式输出消息，每行一个 JSON 对象：

1. **用户消息** (`type: "user"`)
   - 包含用户输入和上下文信息
   - 可能包含工具调用结果 (`toolUseResult`)

2. **助手消息** (`type: "assistant"`)
   - 包含 AI 的响应内容
   - 可能包含工具调用请求

3. **系统消息** (`type: "system"`)
   - 包含会话元数据和状态信息

4. **总结消息** (`type: "summary"`)
   - 包含会话压缩后的摘要

### 消息内容块
助手消息的 `content` 字段可能包含多种内容块：
- **文本块** (`type: "text"`) - 普通文本内容
- **工具使用块** (`type: "tool_use"`) - 工具调用请求
  - `id` - 工具调用ID
  - `name` - 工具名称
  - `input` - 工具参数

## 依赖项

### 运行时依赖

- **Claude CLI**：必须在系统中安装并配置
  ```bash
  npm install -g @anthropic-ai/claude-cli
  claude auth
  ```

### 开发依赖

- Kotlin 2.1.0
- IntelliJ Platform SDK 2025.1.2
- Kotlin Coroutines 1.7.3
- Jackson (JSON 处理)

## 构建和部署

```bash
# 构建插件
./gradlew buildPlugin

# 运行开发环境
./gradlew runIde

# 运行测试
./gradlew test
```

## 支持的功能

除了基本的消息发送和接收，插件还支持以下高级功能：

### 1. 响应打断

- **停止按钮**：UI 中提供停止按钮，可随时中断 AI 响应
- **ESC 快捷键**：按 ESC 键快速停止生成
- **实现机制**：使用 Kotlin 协程的 `Job.cancel()` 和进程的 `process.destroy()`

### 2. 流式响应

- 实时显示 AI 生成的内容
- 使用 `--print` 参数启用非交互模式
- 通过 Kotlin Flow 处理异步数据流
- 消息数据映射：
  - `sdkMessage.data.toolCallId` -> 工具调用ID
  - `sdkMessage.data.toolInput` -> 工具输入参数
  - `sdkMessage.data.toolResult` -> 工具执行结果

### 3. 会话管理

- 支持新建会话
- 支持会话导出
- 未来可扩展支持会话历史

详细功能说明请参考 [FEATURES.md](./FEATURES.md)

## 注意事项

1. **Claude CLI 版本兼容性**：插件依赖于 claude CLI 的命令行接口，需要注意版本兼容性
2. **权限设置**：默认使用 "default" 权限模式，允许所有操作。在生产环境中可能需要调整
3. **错误处理**：CLI 进程可能因各种原因失败（网络、认证等），需要适当的错误处理
4. **进程管理**：确保在打断或错误时正确清理子进程，避免进程泄漏

## 未来改进方向

1. 支持更多的 Claude CLI 功能
2. 改进错误处理和用户提示
3. 添加会话历史管理
4. 支持自定义快捷键
5. 优化流式响应的显示效果# Jewel 组件迁移指南

本文档详细说明了如何将项目中的原生 Compose 组件替换为 IntelliJ Jewel 组件，以获得更好的 IDE 集成和一致的用户体验。

## 为什么要使用 Jewel 组件？

1. **原生 IntelliJ 外观**: Jewel 组件完全匹配 IntelliJ IDEA 的设计语言
2. **主题一致性**: 自动跟随 IDE 的明暗主题切换
3. **平台适配**: 针对不同操作系统（macOS、Windows、Linux）的原生行为
4. **性能优化**: 专为 IDE 环境优化的组件实现
5. **无缝集成**: 与 IntelliJ 插件系统完美配合

## 组件替换对照表

### 1. 文本组件

| 原生组件 | Jewel 组件 | 主要改进 |
|---------|-----------|---------|
| `androidx.compose.material.Text` | `org.jetbrains.jewel.ui.component.Text` | 自动主题集成，更好的颜色管理 |
| `androidx.compose.foundation.text.BasicText` | `org.jetbrains.jewel.ui.component.Text` | 统一的文本样式系统 |

**迁移示例**:
```kotlin
// 原生 Compose
Text(
    "Hello World",
    style = TextStyle(
        color = Color.White,
        fontSize = 14.sp
    )
)

// Jewel 组件
Text(
    "Hello World",
    color = JewelTheme.globalColors.text.normal,
    fontSize = 14.sp
)
```

### 2. 滚动容器

| 原生组件 | Jewel 组件 | 主要改进 |
|---------|-----------|---------|
| `LazyColumn` | `VerticallyScrollableContainer` | 原生滚动条样式，平台特定行为 |
| `LazyRow` | `HorizontallyScrollableContainer` | 自动隐藏/显示逻辑 |

**迁移示例**:
```kotlin
// 原生 Compose
LazyColumn(
    modifier = Modifier.fillMaxSize(),
    verticalArrangement = Arrangement.spacedBy(8.dp),
    contentPadding = PaddingValues(16.dp)
) {
    items(messages) { message ->
        MessageItem(message)
    }
}

// Jewel 组件
VerticallyScrollableContainer(
    scrollState = rememberScrollState(),
    modifier = Modifier.fillMaxSize()
) {
    Column(
        modifier = Modifier.padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        messages.forEach { message ->
            MessageItem(message)
        }
    }
}
```

### 3. 按钮组件

| 原生组件 | Jewel 组件 | 主要改进 |
|---------|-----------|---------|
| `Button` | `DefaultButton` | IntelliJ 按钮样式，交互状态 |
| `OutlinedButton` | `OutlinedButton` | 原生轮廓按钮样式 |
| `IconButton` | `IconButton` | 完整的图标按钮实现 |

**迁移示例**:
```kotlin
// 原生 Compose
Button(
    onClick = { onSend() },
    modifier = Modifier.size(32.dp)
) {
    Text("发送")
}

// Jewel 组件
DefaultButton(
    onClick = { onSend() },
    modifier = Modifier.size(32.dp)
) {
    Text("发送")
}
```

### 4. 输入框组件

| 原生组件 | Jewel 组件 | 主要改进 |
|---------|-----------|---------|
| `BasicTextField` | `TextField` | 原生输入框样式，焦点管理 |
| `OutlinedTextField` | `TextField` | 统一的输入框组件 |
| `TextArea` | `TextArea` | 多行文本输入组件 |

**迁移示例**:
```kotlin
// 原生 Compose
BasicTextField(
    value = text,
    onValueChange = onTextChange,
    textStyle = TextStyle(color = Color.White),
    modifier = Modifier.fillMaxWidth()
)

// Jewel 组件
TextField(
    value = text,
    onValueChange = onTextChange,
    modifier = Modifier.fillMaxWidth()
)
```

### 5. 分隔线组件

| 原生组件 | Jewel 组件 | 主要改进 |
|---------|-----------|---------|
| `Divider` | `org.jetbrains.jewel.ui.component.Divider` | 原生分隔线样式，方向支持 |

**迁移示例**:
```kotlin
// 原生 Compose
Divider(
    color = Color.Gray,
    thickness = 1.dp
)

// Jewel 组件
Divider(
    orientation = Orientation.Horizontal,
    modifier = Modifier.height(1.dp)
)
```

### 6. 其他高级组件

| 原生组件 | Jewel 组件 | 主要改进 |
|---------|-----------|---------|
| `DropdownMenu` | `Menu` | IntelliJ 风格菜单 |
| `Card` | 使用 `Box` + `Jewel` 样式 | 更好的主题集成 |
| `Switch` | `Checkbox` (切换模式) | 原生切换控件 |
| `RadioButton` | `RadioButton` | 原生单选按钮 |

## 完整迁移示例

### 迁移前（原生 Compose）:
```kotlin
@Composable
fun OriginalChatView() {
    Column {
        LazyColumn {
            items(messages) { message ->
                Card {
                    Text(message.content, color = Color.White)
                }
            }
        }
        Divider(color = Color.Gray)
        Row {
            BasicTextField(value = text, onValueChange = {})
            Button(onClick = {}) {
                Text("发送")
            }
        }
    }
}
```

### 迁移后（Jewel）:
```kotlin
@Composable
fun JewelConversationView() {
    Column {
        VerticallyScrollableContainer(rememberScrollState()) {
            Column {
                messages.forEach { message ->
                    Box(
                        modifier = Modifier.background(
                            JewelTheme.globalColors.panelBackground,
                            RoundedCornerShape(8.dp)
                        )
                    ) {
                        Text(
                            message.content,
                            color = JewelTheme.globalColors.text.normal
                        )
                    }
                }
            }
        }
        Divider(orientation = Orientation.Horizontal)
        Row {
            TextField(value = text, onValueChange = {})
            DefaultButton(onClick = {}) {
                Text("发送")
            }
        }
    }
}
```

## 注意事项

### 1. 导入更改
确保更新导入语句：
```kotlin
// 移除
import androidx.compose.material.*
import androidx.compose.foundation.lazy.*

// 添加
import org.jetbrains.jewel.ui.component.*
import org.jetbrains.jewel.foundation.theme.JewelTheme
```

### 2. 主题系统
使用 Jewel 的主题系统而不是硬编码颜色：
```kotlin
// 避免
color = Color.White

// 推荐
color = JewelTheme.globalColors.text.normal
```

### 3. 样式简化
Jewel 组件自动处理样式，无需复杂的 `TextStyle`：
```kotlin
// 原生 Compose
Text(
    "标题",
    style = TextStyle(
        fontSize = 16.sp,
        fontWeight = FontWeight.Bold,
        color = Color.White
    )
)

// Jewel
Text(
    "标题",
    fontSize = 16.sp,
    fontWeight = FontWeight.Bold,
    color = JewelTheme.globalColors.text.normal
)
```

### 4. 渐进式迁移
可以逐步迁移，新旧组件可以共存：
1. 先迁移核心组件（Text、Button）
2. 然后迁移布局容器（ScrollableContainer）
3. 最后迁移高级组件（Menu、Dialog）

## 性能影响

使用 Jewel 组件的性能影响：
- **正面**: 更好的内存管理，专为 IDE 优化
- **负面**: 略微增加的初始化开销
- **整体**: 对用户体验有显著提升

## 兼容性

- **IntelliJ 版本**: 2023.1+
- **Compose 版本**: 与项目当前版本兼容
- **平台支持**: Windows、macOS、Linux

## 下一步

1. 按照优先级迁移组件（Text → Button → Container → Advanced）
2. 测试主题切换功能
3. 验证不同平台的行为一致性
4. 更新相关文档和示例代码

## 迁移优化统计

### 组件替换统计
本项目已完成以下组件的全面替换：

- **LazyColumn** → **VerticallyScrollableContainer**: 4个文件
- **LazyRow** → **HorizontallyScrollableContainer**: 3个文件  
- **BasicTextField** → **TextField**: 3个文件
- **OutlinedButton** → **Button**: 2个文件
- **Material DropdownMenu** → **Jewel Dropdown**: 1个文件

### 已优化的核心文件

1. **JewelConversationView.kt**
   - 使用 `VerticallyScrollableContainer` 替代 `LazyColumn`
   - 使用 `TextField` 替代 `BasicTextField`
   - 完全使用 `JewelTheme.globalColors`

2. **EnhancedSmartInputArea.kt**
   - 优化了上下文菜单和建议系统
   - 使用 Jewel 主题系统
   - 提升了滚动性能

3. **MarkdownRenderer.kt**
   - 使用 Jewel 按钮组件
   - 保持代码渲染功能完整性

4. **ModelSelector.kt**
   - 替换为 Jewel Dropdown
   - 使用主题色彩系统 