# 基于文件监听的会话记录系统

## 概述

本文档描述了 Claude Code Plus 中基于文件监听的会话记录系统的设计和实现。该系统通过监听 Claude CLI 生成的会话文件来实现消息的实时更新，取代了之前基于 CLI 输出解析的方案。

## 背景

### 原有方案的问题

1. **依赖 CLI 输出格式**：需要解析 Claude CLI 的控制台输出，容易受格式变化影响
2. **处理逻辑复杂**：历史会话加载和实时会话更新使用不同的处理逻辑
3. **难以扩展**：不支持会话恢复、跨设备同步等高级功能

### 新方案的优势

1. **统一处理**：历史会话和实时会话使用相同的数据源
2. **更可靠**：直接读取官方会话文件，不依赖 CLI 输出格式
3. **更高效**：支持增量读取，避免重复解析
4. **更灵活**：支持会话恢复、跨设备同步等高级功能

## 系统架构

```
┌─────────────────────────────────────────────────────┐
│                    UI Layer                         │
│        (ChatView, JewelChatPanel, etc.)            │
└────────────────────────┬────────────────────────────┘
                         │
┌────────────────────────┴────────────────────────────┐
│              Session Management Layer               │
│     (SessionManager, SessionObject, etc.)          │
└────────────────────────┬────────────────────────────┘
                         │
┌────────────────────────┴────────────────────────────┐
│            Message Source Abstraction               │
│         (UnifiedMessageSource Interface)            │
└────────────┬───────────────────┬────────────────────┘
             │                   │
┌────────────┴──────┐  ┌─────────┴───────────────────┐
│  File-Based       │  │   CLI Output Parser         │
│  Message Source   │  │   (Legacy, deprecated)      │
└─────────┬─────────┘  └─────────────────────────────┘
          │
┌─────────┴──────────────────────────────────────────┐
│        File Watching Infrastructure                │
│  (SessionFileWatchService, SessionFileTracker)    │
└────────────────────────────────────────────────────┘
```

## 核心组件

### 1. SessionFileWatchService

**职责**：管理文件监听服务，监控会话目录的变化

**主要功能**：
- 使用 Hutool 的 WatchMonitor 监听文件系统事件
- 管理多个项目的监听器实例
- 分发文件变化事件到相应的会话

**关键方法**：
```kotlin
fun startWatchingProject(projectPath: String)
fun getOrCreateTracker(sessionId: String, projectPath: String): SessionFileTracker
fun subscribeToSession(sessionId: String): Flow<List<ClaudeSessionMessage>>
```

### 2. SessionFileTracker

**职责**：追踪单个会话文件的变化，支持增量读取

**主要功能**：
- 使用行号索引追踪读取位置
- 支持增量读取新消息
- 处理文件编码和格式错误

**实现细节**：
- 首次读取建立基线，不返回消息
- 后续读取只返回新增的行
- 使用 RandomAccessFile 优化大文件读取

### 3. MessageFlowConverter

**职责**：将 Claude 会话消息转换为 UI 层使用的 EnhancedMessage

**主要功能**：
- 消息类型转换
- 消息去重
- 工具调用处理
- 消息关联

### 4. FileBasedMessageSource

**职责**：实现 UnifiedMessageSource 接口，提供基于文件的消息源

**主要功能**：
- 历史消息加载
- 实时消息订阅
- 消息缓存
- 错误处理

### 5. UnifiedMessageSource

**职责**：定义统一的消息源接口

**接口方法**：
```kotlin
suspend fun loadHistoricalMessages(sessionId: String, projectPath: String): List<EnhancedMessage>
fun subscribeToNewMessages(sessionId: String, projectPath: String): Flow<EnhancedMessage>
suspend fun sessionExists(sessionId: String, projectPath: String): Boolean
```

## 文件结构

```
~/.claude/projects/{encodedProjectPath}/
├── {sessionId1}.jsonl
├── {sessionId2}.jsonl
└── ...
```

每个 JSONL 文件包含一个会话的所有消息，每行一个 JSON 对象。

## 消息格式

```json
{
  "uuid": "message-uuid",
  "sessionId": "session-id",
  "type": "user|assistant|system|result",
  "timestamp": "ISO8601 timestamp",
  "message": {
    "role": "user|assistant",
    "content": "message content or content blocks",
    "id": "message-id",
    "model": "model-name",
    "usage": {
      "input_tokens": 100,
      "output_tokens": 200
    }
  },
  "cwd": "/working/directory",
  "version": "1.0.0"
}
```

## 使用方式

### 1. 启用文件监听

```kotlin
// 创建带文件监听的 SessionManager
val sessionManager = SessionManager(
    scope = lifecycleScope,
    enableFileWatching = true
)
```

### 2. 加载历史消息

```kotlin
val messageSource = FileBasedMessageSource(fileWatchService, scope)
val historicalMessages = messageSource.loadHistoricalMessages(sessionId, projectPath)
```

### 3. 订阅新消息

```kotlin
messageSource.subscribeToNewMessages(sessionId, projectPath)
    .collect { newMessage ->
        // 处理新消息
    }
```

## 配置选项

通过 `MessageSourceConfig` 控制系统行为：

```kotlin
data class MessageSourceConfig(
    val sourceType: MessageSourceType = MessageSourceType.FILE_BASED,
    val enableCache: Boolean = true,
    val cacheSize: Int = 1000,
    val enableDeduplication: Boolean = true,
    val fileCheckInterval: Long = 100,
    val maxRetries: Int = 3,
    val retryDelay: Long = 1000
)
```

## 错误处理

### 文件系统错误

使用 `FileSystemErrorHandler` 统一处理：
- 文件不存在
- 权限不足
- 文件锁定
- IO 错误

### 重试机制

```kotlin
val result = errorHandler.withRetry(
    config = RetryConfig(maxAttempts = 3, initialDelay = 100.ms)
) {
    // 文件操作
}
```

## 性能优化

1. **增量读取**：只读取新增的消息，避免重复解析
2. **消息缓存**：缓存最近的消息，减少文件读取
3. **并发控制**：使用 Mutex 保证线程安全
4. **延迟加载**：首次读取只建立基线，不加载历史消息

## 迁移策略

### 第一阶段：并行运行

- 新旧系统同时运行
- 通过配置开关控制
- 收集对比数据

### 第二阶段：逐步切换

- 新会话使用文件监听
- 旧会话继续使用 CLI 输出
- 监控错误率

### 第三阶段：完全迁移

- 所有会话使用文件监听
- 移除 CLI 输出解析代码
- 简化系统架构

## 测试策略

### 单元测试

- `SessionFileTrackerTest`：测试增量读取逻辑
- `MessageFlowConverterTest`：测试消息转换
- `FileSystemErrorHandlerTest`：测试错误处理

### 集成测试

- `FileWatchServiceIntegrationTest`：测试文件监听
- `FileBasedMessageSourceTest`：测试消息源
- 端到端测试：测试完整流程

## 未来扩展

1. **会话同步**：支持多设备间的会话同步
2. **离线支持**：缓存消息供离线查看
3. **消息搜索**：基于文件的全文搜索
4. **会话导出**：导出会话为各种格式
5. **增量备份**：基于文件变化的增量备份

## 注意事项

1. **文件锁定**：Windows 下可能遇到文件锁定问题，需要重试机制
2. **编码问题**：确保正确处理 UTF-8 编码
3. **性能监控**：监控文件监听的资源消耗
4. **错误恢复**：监听服务异常时的自动恢复机制