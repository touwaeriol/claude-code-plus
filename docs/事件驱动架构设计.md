# Claude Code Plus 事件驱动架构设计

## 背景问题

### 当前文件监听架构的问题
1. **会话文件断链**: Claude CLI 在 `--print` 模式下，每次 `--resume` 都会创建新的会话文件
2. **监听目标错误**: UI 组件监听旧的会话文件，而新消息写入到新文件中
3. **消息显示中断**: 用户发送消息后，界面无法显示 Claude 的响应

### 根本原因分析
基于对 Claudia 项目的深入分析和实际测试确认：
- Claude CLI 的 `--resume sessionId` 参数在 `--print` 模式下不会复用原会话文件
- 每次调用都生成新的 sessionId 和对应的 .jsonl 文件
- Claude 通过 `leafUuid` 机制保持会话连续性，但这对文件监听系统透明

## 解决方案：事件驱动架构

### 核心设计理念
参考 Claudia 项目的成功实现，采用**进程流监听**替代**文件系统监听**：
- 直接监听 Claude CLI 进程的 stdout/stderr 流
- 实时解析 JSONL 消息并触发 UI 更新
- 避免文件系统 I/O 延迟和文件路径问题

## 架构设计

### 1. 核心组件设计

#### ClaudeProcessEventHandler
```kotlin
/**
 * Claude CLI 进程事件处理器
 * 负责启动进程、监听输出流、解析消息并分发事件
 */
class ClaudeProcessEventHandler {
    suspend fun executeWithEvents(
        command: List<String>,
        workingDirectory: String,
        onOutput: (String) -> Unit,
        onError: (String) -> Unit, 
        onComplete: (Boolean) -> Unit
    ): Process {
        val processBuilder = ProcessBuilder(command)
            .directory(File(workingDirectory))
            .redirectErrorStream(false)
        
        val process = processBuilder.start()
        
        // 启动输出流监听协程
        launch { 
            process.inputStream.bufferedReader().use { reader ->
                reader.lineSequence().forEach { line ->
                    onOutput(line)
                }
            }
        }
        
        // 启动错误流监听协程
        launch {
            process.errorStream.bufferedReader().use { reader ->
                reader.lineSequence().forEach { line ->
                    onError(line)
                }
            }
        }
        
        return process
    }
}
```

#### ClaudeEventService
```kotlin
/**
 * Claude 会话事件服务
 * 管理会话生命周期，处理消息流，维护会话状态
 * 完全符合 Claudia 项目的会话管理策略
 */
class ClaudeEventService(
    private val processHandler: ClaudeProcessEventHandler,
    private val cliWrapper: ClaudeCliWrapper,
    private val historyLoader: SessionHistoryLoader
) {
    
    /**
     * 启动新会话（对应 Claudia 的 executeClaudeCode）
     */
    fun startNewSession(
        projectPath: String, 
        prompt: String,
        options: QueryOptions
    ): Flow<ClaudeEvent> = flow {
        // 不使用 --resume 参数，创建全新会话
        val command = cliWrapper.buildCommand(prompt, options.copy(resume = null))
        
        val process = processHandler.executeWithEvents(
            command = command,
            workingDirectory = projectPath,
            onOutput = { jsonLine ->
                try {
                    val message = parseJsonLine(jsonLine)
                    emit(ClaudeEvent.MessageReceived(message))
                } catch (e: Exception) {
                    emit(ClaudeEvent.ParseError(jsonLine, e))
                }
            },
            onError = { errorLine ->
                emit(ClaudeEvent.ProcessError(errorLine))
            },
            onComplete = { success ->
                emit(ClaudeEvent.ProcessComplete(success))
            }
        )
        
        // 等待进程完成
        val exitCode = process.waitFor()
        emit(ClaudeEvent.SessionComplete(exitCode == 0))
    }
    
    /**
     * 恢复已有会话（对应 Claudia 的 resumeClaudeCode）
     * 关键：先预加载历史，再继续会话
     */
    fun resumeExistingSession(
        sessionId: String,
        projectPath: String,
        prompt: String,
        options: QueryOptions
    ): Flow<ClaudeEvent> = flow {
        // 1. 先预加载历史记录（关键步骤，符合 Claudia 模式）
        try {
            val historyMessages = historyLoader.loadSessionHistory(sessionId, projectPath)
            historyMessages.forEach { message ->
                emit(ClaudeEvent.HistoryMessageLoaded(message))
            }
        } catch (e: Exception) {
            emit(ClaudeEvent.HistoryLoadError(e.message ?: "Failed to load history"))
        }
        
        // 2. 然后使用 --resume 继续会话
        val resumeOptions = options.copy(resume = sessionId)
        val command = cliWrapper.buildCommand(prompt, resumeOptions)
        
        val process = processHandler.executeWithEvents(
            command = command,
            workingDirectory = projectPath,
            onOutput = { jsonLine ->
                try {
                    val message = parseJsonLine(jsonLine)
                    emit(ClaudeEvent.MessageReceived(message))
                } catch (e: Exception) {
                    emit(ClaudeEvent.ParseError(jsonLine, e))
                }
            },
            onError = { errorLine ->
                emit(ClaudeEvent.ProcessError(errorLine))
            },
            onComplete = { success ->
                emit(ClaudeEvent.ProcessComplete(success))
            }
        )
        
        // 等待进程完成
        val exitCode = process.waitFor()
        emit(ClaudeEvent.SessionComplete(exitCode == 0))
    }
    
    /**
     * 智能会话处理（根据是否为首次消息选择策略）
     * 完全模仿 Claudia 的逻辑：
     * - 首次消息或无会话 -> executeClaudeCode (无 --resume 参数)
     * - 所有后续消息 -> resumeClaudeCode (使用 --resume sessionId)
     * 
     * 关键发现：Claudia 只使用两种策略，不使用 continue_claude_code
     * 同一会话内的多轮对话都通过 resumeClaudeCode 处理
     */
    fun handleMessage(
        sessionId: String?,
        isFirstMessage: Boolean,
        projectPath: String,
        prompt: String,
        options: QueryOptions
    ): Flow<ClaudeEvent> {
        return if (sessionId != null && !isFirstMessage) {
            // 有会话ID且非首次消息 -> 使用 --resume 恢复会话
            // 这里包括：从会话列表打开 + 同一会话内的连续对话
            resumeExistingSession(sessionId, projectPath, prompt, options)
        } else {
            // 无会话ID或首次消息 -> 创建新会话（无 --resume 参数）
            startNewSession(projectPath, prompt, options)
        }
    }
}
```

#### ClaudeEvent 密封类
```kotlin
/**
 * Claude 会话事件定义
 * 支持历史记录加载和实时消息接收
 */
sealed class ClaudeEvent {
    // 实时消息事件
    data class MessageReceived(val message: SDKMessage) : ClaudeEvent()
    
    // 历史消息事件（预加载时使用）
    data class HistoryMessageLoaded(val message: SDKMessage) : ClaudeEvent()
    data class HistoryLoadError(val error: String) : ClaudeEvent()
    
    // 进程和错误事件
    data class ProcessError(val error: String) : ClaudeEvent()
    data class ParseError(val rawLine: String, val exception: Exception) : ClaudeEvent()
    data class ProcessComplete(val success: Boolean) : ClaudeEvent()
    data class SessionComplete(val success: Boolean) : ClaudeEvent()
}
```

### 2. UI 组件集成

#### ChatView 改造
```kotlin
@Composable
fun ChatView(
    projectPath: String,
    sessionObject: SessionObject,
    eventService: ClaudeEventService
) {
    // 移除文件监听相关代码
    // 替换为完全符合 Claudia 模式的事件监听
    
    // 不需要手动加载历史，事件服务会自动处理
    // LaunchedEffect 仅用于初始化，不加载历史
    
    // 发送消息处理（完全模仿 Claudia 的 handleSendPrompt）
    fun sendMessage(prompt: String) {
        sessionObject.isGenerating.value = true
        
        launch {
            // 关键状态判断，完全符合 Claudia 的逻辑：
            // 1. sessionObject.sessionId 存在 -> 从会话列表恢复的会话
            // 2. sessionObject.messages.isEmpty() -> 是否为该会话的首次消息
            // 
            // Claudia 逻辑：if (effectiveSession && !isFirstPrompt)
            val isFirstMessage = sessionObject.messages.isEmpty()
            val effectiveSessionId = sessionObject.sessionId // 对应 effectiveSession
            
            val eventFlow = eventService.handleMessage(
                sessionId = effectiveSessionId,
                isFirstMessage = isFirstMessage,
                projectPath = projectPath,
                prompt = prompt,
                options = buildQueryOptions(sessionObject)
            )
            
            eventFlow.collect { event ->
                when (event) {
                    is ClaudeEvent.HistoryMessageLoaded -> {
                        // 历史消息加载（对应 Claudia 的 setMessages(loadedMessages)）
                        // 只有从会话列表恢复会话时才会有这个事件
                        processHistoryMessage(event.message, sessionObject)
                    }
                    is ClaudeEvent.MessageReceived -> {
                        // 实时消息处理
                        processMessage(event.message, sessionObject)
                        
                        // 提取会话 ID（对应 Claudia 的 extractSessionInfo）
                        // 新会话的第一次响应会包含系统初始化消息
                        if (sessionObject.sessionId == null && event.message.sessionId != null) {
                            sessionObject.sessionId = event.message.sessionId
                            // 从第二轮开始，isFirstMessage 将为 false
                        }
                    }
                    is ClaudeEvent.HistoryLoadError -> {
                        sessionObject.errorMessage.value = "历史记录加载失败: ${event.error}"
                    }
                    is ClaudeEvent.ProcessError -> {
                        sessionObject.errorMessage.value = event.error
                    }
                    is ClaudeEvent.SessionComplete -> {
                        sessionObject.isGenerating.value = false
                    }
                }
            }
        }
    }
    
    // 会话恢复时的处理（对应 Claudia 的 loadSessionHistory）
    LaunchedEffect(sessionObject.sessionId) {
        // 如果是从会话列表打开的会话，sessionId 已存在
        // 历史加载会在第一次 sendMessage 时自动处理
        // 这里不需要额外操作，完全符合 Claudia 的延迟加载模式
    }
}
```

### 3. 历史消息加载策略

#### 混合加载方案
```kotlin
class SessionHistoryLoader {
    /**
     * 加载会话历史消息
     * 1. 先加载主会话文件
     * 2. 通过 leafUuid 链接加载相关会话文件
     * 3. 按时间戳排序合并消息
     */
    suspend fun loadSessionHistory(sessionId: String, projectPath: String): List<SDKMessage> {
        val claudeProjectDir = getClaudeProjectDir(projectPath)
        val sessionFile = File(claudeProjectDir, "$sessionId.jsonl")
        
        if (!sessionFile.exists()) {
            return emptyList()
        }
        
        val messages = mutableListOf<SDKMessage>()
        val processedFiles = mutableSetOf<String>()
        val filesToProcess = mutableListOf<String>()
        
        filesToProcess.add(sessionId)
        
        while (filesToProcess.isNotEmpty()) {
            val currentSessionId = filesToProcess.removeFirst()
            if (currentSessionId in processedFiles) continue
            
            val currentFile = File(claudeProjectDir, "$currentSessionId.jsonl")
            if (!currentFile.exists()) continue
            
            val fileMessages = currentFile.readLines()
                .mapNotNull { line -> parseJsonLine(line) }
            
            messages.addAll(fileMessages)
            processedFiles.add(currentSessionId)
            
            // 查找引用的其他会话（通过 leafUuid）
            fileMessages.forEach { message ->
                message.leafUuid?.let { leafUuid ->
                    // 查找包含此 leafUuid 的其他文件
                    findSessionByLeafUuid(claudeProjectDir, leafUuid)?.let { referencedSessionId ->
                        if (referencedSessionId !in processedFiles) {
                            filesToProcess.add(referencedSessionId)
                        }
                    }
                }
            }
        }
        
        // 按时间戳排序
        return messages.sortedBy { it.timestamp }
    }
}
```

### 4. 错误处理和容错机制

#### 进程监控
```kotlin
class ProcessMonitor {
    private val activeProcesses = mutableMapOf<String, Process>()
    
    fun registerProcess(sessionId: String, process: Process) {
        activeProcesses[sessionId] = process
    }
    
    fun terminateSession(sessionId: String) {
        activeProcesses[sessionId]?.let { process ->
            if (process.isAlive) {
                process.destroyForcibly()
            }
            activeProcesses.remove(sessionId)
        }
    }
    
    fun terminateAll() {
        activeProcesses.values.forEach { process ->
            if (process.isAlive) {
                process.destroyForcibly()
            }
        }
        activeProcesses.clear()
    }
}
```

#### 重连机制
```kotlin
class ReconnectionHandler {
    private var retryCount = 0
    private val maxRetries = 3
    
    suspend fun executeWithRetry(
        operation: suspend () -> Flow<ClaudeEvent>
    ): Flow<ClaudeEvent> = flow {
        while (retryCount < maxRetries) {
            try {
                operation().collect { event ->
                    emit(event)
                }
                retryCount = 0 // 重置重试计数
                return@flow
            } catch (e: Exception) {
                retryCount++
                emit(ClaudeEvent.ProcessError("连接失败，尝试重连... ($retryCount/$maxRetries)"))
                
                if (retryCount >= maxRetries) {
                    emit(ClaudeEvent.ProcessError("重连失败，已达最大重试次数"))
                    return@flow
                }
                
                delay(1000 * retryCount) // 递增延迟
            }
        }
    }
}
```

## 实施计划

### 第一阶段：核心组件实现
1. **ClaudeProcessEventHandler** - 进程监听和事件分发
2. **ClaudeEvent** - 事件类型定义
3. **ClaudeEventService** - 会话管理服务

### 第二阶段：UI 组件改造
1. **移除文件监听系统**:
   - `SessionFileWatchService` 
   - `UnifiedSessionService.subscribeToSession()`
   - 相关的文件监听逻辑

2. **ChatView 集成**:
   - 替换 `subscribeToSession()` 调用为事件监听
   - 添加 `ClaudeEventService` 依赖注入
   - 更新消息发送逻辑

### 第三阶段：历史加载优化
1. **SessionHistoryLoader** - 智能历史加载
2. **leafUuid 链接解析** - 跨会话文件的消息链接
3. **缓存机制** - 减少重复文件读取

### 第四阶段：错误处理和监控
1. **ProcessMonitor** - 进程生命周期管理
2. **ReconnectionHandler** - 自动重连机制
3. **详细日志记录** - 调试和问题定位

## 优势分析

### 相比文件监听的优势
1. **实时性**: 消息到达时立即处理，无文件系统延迟
2. **可靠性**: 不受会话文件切换影响，直接从源头获取数据
3. **简单性**: 消除了复杂的文件路径匹配和监听逻辑
4. **性能**: 减少文件系统 I/O 操作，降低资源消耗

### 与 Claudia 项目的对比

**完全一致的核心策略**：
1. **会话管理逻辑**：完全采用 Claudia 的二元策略
   - 新会话：`executeClaudeCode`（无 --resume 参数）
   - 所有后续消息：`resumeClaudeCode`（使用 --resume sessionId）
2. **CLI 参数一致性**：所有命令都使用相同的核心参数
   - `--output-format stream-json`
   - `--verbose`
   - `--dangerously-skip-permissions`
3. **事件驱动架构**：都采用进程流监听替代文件监听
4. **历史预加载**：会话恢复时先加载历史再继续对话

**技术实现差异**：
- **事件系统**：Claudia 使用 Tauri 事件系统，我们使用 Kotlin 协程和 Flow
- **编程语言**：Claudia 使用 Rust，我们使用 Kotlin JVM  
- **集成平台**：Claudia 是独立应用，我们是 IntelliJ 插件

**关键发现确认**：
- Claudia 项目中存在 `continueClaudeCode` 函数，但前端**从未调用**
- 同一会话内的多轮对话全部通过 `resumeClaudeCode` 处理
- 这验证了我们的架构设计完全符合 Claudia 的实际工作模式

## 兼容性考虑

### 现有功能保持
- 会话列表显示
- 会话导出功能  
- 多标签管理（后台）
- 权限设置和模型选择

### 配置迁移
- 现有的会话配置文件保持兼容
- 项目配置和 MCP 设置不受影响
- 用户设置和快捷键保持不变

## 测试策略

### 单元测试
- ClaudeProcessEventHandler 进程启动和监听
- ClaudeEventService 事件处理逻辑
- SessionHistoryLoader 历史加载功能

### 集成测试  
- 完整会话流程测试
- 多会话并发测试
- 错误恢复测试

### 用户接受测试
- 消息发送和接收的实时性
- 界面响应速度对比
- 长时间使用稳定性

## 风险评估

### 潜在风险
1. **进程管理复杂性**: 需要妥善处理进程生命周期
2. **内存泄漏**: 协程和流的资源管理
3. **平台兼容性**: 不同操作系统的进程行为差异

### 缓解措施
1. **自动清理机制**: 组件销毁时自动终止相关进程
2. **资源监控**: 添加内存和协程使用监控
3. **平台测试**: 在 Windows、macOS、Linux 上充分测试

## 总结

基于对 Claudia 项目深入分析，我们的事件驱动架构设计**完全符合**其成功的实现模式：

### 核心优势
1. **直接解决根本问题**: 彻底解决会话文件断链导致的消息显示中断
2. **实时性大幅提升**: 进程流监听比文件监听更快更可靠
3. **架构简化**: 消除复杂的文件路径匹配和监听逻辑
4. **资源优化**: 减少文件系统 I/O，降低CPU和内存占用

### 与 Claudia 完全一致
- **会话策略**: 采用完全相同的二元会话管理策略
- **CLI 参数**: 在新会话、延续会话等场景下使用一样的参数
- **历史加载**: 相同的预加载历史记录机制
- **事件监听**: 相同的进程流监听替代文件监听的方案

### 实现价值
这个架构改造不仅解决了当前的技术问题，更重要的是：
- **借鉴成功经验**: 完全复制了 Claudia 项目的成功模式
- **保证稳定性**: 基于经过验证的成熟架构设计
- **提升用户体验**: 实现与 Claudia 相同的流畅对话体验
- **便于后续维护**: 代码逻辑更清晰，调试更容易

这个完全符合 Claudia 实现方式的事件驱动架构将显著提升 Claude Code Plus 的用户体验和系统稳定性。