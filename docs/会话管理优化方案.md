# 会话管理优化方案

## 问题分析

### 当前存在的问题
1. **启动延迟**：打开插件时总是尝试加载历史会话文件（延迟1秒）
2. **切换卡顿**：工具窗口切换时重新加载状态，导致明显延迟
3. **输入丢失**：切换窗口后输入框内容丢失
4. **消息不显示**：发送消息后无法正确渲染到对话列表
5. **架构混乱**：多个SessionManager、多重状态管理，逻辑复杂

### 根本原因
- 混淆了"会话恢复"和"状态保持"两个概念
- 过度依赖文件系统，频繁进行文件I/O
- 状态管理分散，没有单一数据源
- UI组件和业务逻辑耦合严重

## 设计目标

### 核心原则
1. **即时响应**：打开插件立即可用，无需等待
2. **无缝切换**：工具窗口切换完全无感知
3. **状态保持**：输入框内容、滚动位置等UI状态保持
4. **实时更新**：CLI输出实时渲染，无需监听文件

### 行为规范
1. **新会话**：打开插件默认创建新会话，立即可用
2. **会话恢复**：只有用户主动选择时才加载历史会话
3. **状态保持**：切换窗口时所有状态在内存中保持
4. **进程监听**：直接监听CLI进程输出，不监听文件

## 架构设计

### 三层架构

```
┌─────────────────────────────────────────────┐
│              UI 层                           │
│  ChatViewNew - 纯UI组件，无业务逻辑          │
│  - 显示消息列表                              │
│  - 管理输入框状态                            │
│  - 响应用户操作                              │
└─────────────────────────────────────────────┘
                       ↕
┌─────────────────────────────────────────────┐
│           会话管理层                          │
│  SessionStateManager - 单一状态管理器         │
│  - 管理当前会话状态                          │
│  - 处理CLI进程输出                           │
│  - 提供响应式状态流                          │
└─────────────────────────────────────────────┘
                       ↕
┌─────────────────────────────────────────────┐
│           后台服务层                          │
│  BackgroundSessionService - 应用级服务        │
│  - 管理CLI进程生命周期                       │
│  - 保持会话状态                              │
│  - 处理多项目/多会话                         │
└─────────────────────────────────────────────┘
```

### 状态管理

#### SessionState 数据结构
```kotlin
data class SessionState(
    val sessionId: String,
    val messages: List<EnhancedMessage>,
    val inputText: String,           // 输入框内容
    val scrollPosition: Float,       // 滚动位置
    val isGenerating: Boolean,       // 是否正在生成
    val cliProcess: Process?,        // CLI进程引用
    val selectedContexts: List<Context>, // 选中的上下文
    val selectedModel: String        // 选中的模型
)
```

#### 状态流转
1. **初始化**：创建空的SessionState
2. **用户输入**：更新inputText
3. **发送消息**：
   - 清空inputText
   - 添加用户消息到messages
   - 启动CLI进程
   - 设置isGenerating = true
4. **接收输出**：
   - 解析CLI输出
   - 更新messages
   - 完成时设置isGenerating = false
5. **窗口切换**：状态保持在内存，无需任何操作

## 实现方案

### 1. 简化SessionStateManager
```kotlin
class SessionStateManager(
    private val sessionId: String,
    private val workingDirectory: String
) {
    private val _state = MutableStateFlow(SessionState.empty())
    val state: StateFlow<SessionState> = _state
    
    private var cliProcess: Process? = null
    private var outputReader: Job? = null
    
    fun sendMessage(
        message: String,
        contexts: List<Context>,
        model: String
    ) {
        // 1. 添加用户消息
        _state.update { 
            it.copy(
                messages = it.messages + EnhancedMessage.user(message),
                isGenerating = true
            )
        }
        
        // 2. 启动CLI进程
        cliProcess = startCliProcess(message, contexts, model)
        
        // 3. 监听输出
        outputReader = GlobalScope.launch {
            cliProcess?.inputStream?.bufferedReader()?.use { reader ->
                reader.lines().forEach { line ->
                    processCliOutput(line)
                }
            }
            _state.update { it.copy(isGenerating = false) }
        }
    }
    
    fun updateInputText(text: String) {
        _state.update { it.copy(inputText = text) }
    }
    
    fun updateScrollPosition(position: Float) {
        _state.update { it.copy(scrollPosition = position) }
    }
    
    private fun processCliOutput(line: String) {
        // 解析CLI输出并更新消息
        val event = parseCliEvent(line)
        when (event) {
            is MessageEvent -> {
                _state.update { 
                    it.copy(messages = it.messages + event.message)
                }
            }
            is StreamingEvent -> {
                _state.update {
                    val lastMessage = it.messages.lastOrNull()
                    if (lastMessage?.role == "assistant") {
                        it.copy(
                            messages = it.messages.dropLast(1) + 
                                lastMessage.copy(content = lastMessage.content + event.text)
                        )
                    } else it
                }
            }
        }
    }
}
```

### 2. 优化ChatViewNew
```kotlin
@Composable
fun ChatViewNew(
    sessionManager: SessionStateManager,
    modifier: Modifier = Modifier
) {
    val state by sessionManager.state.collectAsState()
    
    Column(modifier = modifier.fillMaxSize()) {
        // 消息列表
        MessageList(
            messages = state.messages,
            scrollPosition = state.scrollPosition,
            onScrollChange = { sessionManager.updateScrollPosition(it) },
            modifier = Modifier.weight(1f)
        )
        
        // 输入区域
        ChatInputArea(
            text = state.inputText,
            onTextChange = { sessionManager.updateInputText(it) },
            onSend = { text, contexts, model ->
                sessionManager.sendMessage(text, contexts, model)
            },
            isGenerating = state.isGenerating,
            selectedContexts = state.selectedContexts,
            selectedModel = state.selectedModel
        )
    }
}
```

### 3. 后台服务优化
```kotlin
@Service
class BackgroundSessionService : Service {
    private val sessions = mutableMapOf<String, SessionStateManager>()
    
    fun getOrCreateSession(
        projectPath: String,
        sessionId: String
    ): SessionStateManager {
        val key = "$projectPath:$sessionId"
        return sessions.getOrPut(key) {
            SessionStateManager(sessionId, projectPath)
        }
    }
    
    fun getSession(projectPath: String, sessionId: String): SessionStateManager? {
        return sessions["$projectPath:$sessionId"]
    }
    
    // 清理超时会话
    fun cleanupInactiveSessions() {
        val timeout = 24 * 60 * 60 * 1000L // 24小时
        val now = System.currentTimeMillis()
        
        sessions.entries.removeIf { (_, manager) ->
            val lastActivity = manager.state.value.lastActivity
            now - lastActivity > timeout
        }
    }
}
```

### 4. 工具窗口工厂优化
```kotlin
class ClaudeCodePlusToolWindowFactory : ToolWindowFactory {
    override fun createToolWindowContent(project: Project, toolWindow: ToolWindow) {
        val backgroundService = service<BackgroundSessionService>()
        val sessionManager = backgroundService.getOrCreateSession(
            project.basePath ?: "",
            "main"  // 默认会话ID
        )
        
        // 直接创建UI，无需延迟加载
        val composePanel = ComposePanel().apply {
            setContent {
                JewelTheme {
                    ChatViewNew(
                        sessionManager = sessionManager
                    )
                }
            }
        }
        
        val content = ContentFactory.getInstance()
            .createContent(composePanel, "", false)
        toolWindow.contentManager.addContent(content)
    }
}
```

## 实施步骤

### 第一阶段：清理无用代码
1. 移除多余的SessionManager类
2. 删除文件监听相关代码
3. 简化SessionObject，只保留核心功能
4. 移除延迟加载逻辑

### 第二阶段：实现新架构
1. 创建简化的SessionStateManager
2. 重构ChatViewNew为纯UI组件
3. 实现进程输出监听
4. 优化后台服务

### 第三阶段：功能完善
1. 实现会话恢复功能（用户主动触发）
2. 添加会话列表管理
3. 实现多标签支持
4. 添加错误处理

### 第四阶段：性能优化
1. 优化消息渲染性能
2. 实现虚拟滚动
3. 添加消息缓存
4. 优化内存使用

## 预期效果

### 性能指标
- 插件启动时间：< 100ms
- 窗口切换延迟：0ms（无感知）
- 消息渲染延迟：< 50ms
- 内存占用：< 100MB

### 用户体验
- ✅ 打开插件立即可用
- ✅ 切换窗口完全无感
- ✅ 输入内容不丢失
- ✅ 消息实时显示
- ✅ 操作流畅自然

## 注意事项

1. **向后兼容**：保留历史会话文件读取能力，但作为可选功能
2. **错误处理**：CLI进程异常时的优雅降级
3. **资源管理**：确保进程和协程的正确清理
4. **测试覆盖**：重点测试窗口切换、进程管理、状态同步

## 总结

通过这次重构，我们将实现一个真正响应迅速、体验流畅的聊天插件。核心改进包括：

1. **去除不必要的文件I/O**，所有操作基于内存
2. **简化状态管理**，使用单一数据源
3. **优化启动流程**，移除延迟加载
4. **改进进程管理**，直接监听CLI输出

这将彻底解决当前的性能问题，提供与其他专业插件相当的用户体验。