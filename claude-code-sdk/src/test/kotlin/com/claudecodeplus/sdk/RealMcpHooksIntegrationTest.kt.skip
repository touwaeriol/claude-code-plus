package com.claudecodeplus.sdk

import com.claudecodeplus.sdk.types.*
import kotlinx.coroutines.*
import kotlinx.serialization.json.JsonPrimitive
import org.junit.jupiter.api.Test
import java.io.File
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import kotlin.test.*

/**
 * çœŸå®çš„ MCP + Hooks é›†æˆæµ‹è¯•
 * è®© AI çœŸæ­£è°ƒç”¨æˆ‘ä»¬çš„è‡ªå®šä¹‰ MCP å·¥å…·ï¼Œå¹¶éªŒè¯ hooks æ­£å¸¸å·¥ä½œ
 */
class RealMcpHooksIntegrationTest {

    companion object {
        // æµ‹è¯•ç”¨çš„ä¸´æ—¶æ–‡ä»¶
        private const val TEST_FILE_PATH = "/tmp/claude_mcp_test.txt"
        private const val TEST_CONTENT = "Hello from Claude MCP Test!"
        
        // Hook è°ƒç”¨è®¡æ•°å™¨
        private val preToolHookCalls = AtomicInteger(0)
        private val postToolHookCalls = AtomicInteger(0)
        private val mcpToolWasCalled = AtomicBoolean(false)
        private val securityCheckTriggered = AtomicBoolean(false)
    }

    /**
     * å®‰å…¨æ£€æŸ¥ Hook - åœ¨å·¥å…·è°ƒç”¨å‰æ‰§è¡Œ
     */
    private val securityHook: HookCallback = securityHook@{ input, toolUseId, context ->
        val toolName = input["tool_name"] as? String ?: ""
        val toolInput = input["tool_input"] as? Map<*, *> ?: emptyMap<String, Any>()
        
        preToolHookCalls.incrementAndGet()
        
        println("ğŸ”’ [PRE_TOOL_USE] å®‰å…¨æ£€æŸ¥: $toolName")
        println("   å·¥å…·è¾“å…¥: $toolInput")
        println("   å·¥å…·ID: $toolUseId")
        
        if (toolName.startsWith("mcp__")) {
            val parts = toolName.split("__")
            val serverName = if (parts.size >= 2) parts[1] else "unknown"
            val toolFunction = if (parts.size >= 3) parts[2] else "unknown"
            
            println("   ğŸ”§ MCP å·¥å…·è¯¦æƒ…: æœåŠ¡å™¨=$serverName, åŠŸèƒ½=$toolFunction")
            securityCheckTriggered.set(true)
            
            // å®‰å…¨ç­–ç•¥ï¼šé˜»æ­¢å±é™©çš„æ–‡ä»¶æ“ä½œ
            when (toolFunction) {
                "write_file" -> {
                    val path = toolInput["path"] as? String ?: ""
                    if (!path.startsWith("/tmp/")) {
                        println("   ğŸš« é˜»æ­¢å±é™©çš„å†™æ–‡ä»¶æ“ä½œ: $path")
                        return@securityHook HookJSONOutput(
                            decision = "block",
                            systemMessage = "å®‰å…¨ç­–ç•¥: åªèƒ½å‘ /tmp/ ç›®å½•å†™å…¥æ–‡ä»¶",
                            hookSpecificOutput = JsonPrimitive("unsafe_write_blocked")
                        )
                    }
                }
                "calculate" -> {
                    val expression = toolInput["expression"] as? String ?: ""
                    if (expression.contains("import") || expression.contains("exec")) {
                        println("   ğŸš« é˜»æ­¢å±é™©çš„è®¡ç®—è¡¨è¾¾å¼: $expression")
                        return@securityHook HookJSONOutput(
                            decision = "block",
                            systemMessage = "å®‰å…¨ç­–ç•¥: è¡¨è¾¾å¼ä¸èƒ½åŒ…å«å±é™©æ“ä½œ",
                            hookSpecificOutput = JsonPrimitive("dangerous_expression_blocked")
                        )
                    }
                }
            }
            
            println("   âœ… MCP å·¥å…·å®‰å…¨æ£€æŸ¥é€šè¿‡")
        }
        
        HookJSONOutput(systemMessage = "âœ… å®‰å…¨æ£€æŸ¥é€šè¿‡")
    }

    /**
     * å®¡è®¡ Hook - åœ¨å·¥å…·è°ƒç”¨åæ‰§è¡Œ
     */
    private val auditHook: HookCallback = { input, toolUseId, context ->
        val toolName = input["tool_name"] as? String ?: ""
        
        postToolHookCalls.incrementAndGet()
        
        println("ğŸ“‹ [POST_TOOL_USE] å®¡è®¡è®°å½•: $toolName")
        println("   å·¥å…·ID: $toolUseId")
        println("   æ—¶é—´æˆ³: ${System.currentTimeMillis()}")
        
        if (toolName.startsWith("mcp__")) {
            val parts = toolName.split("__")
            val serverName = if (parts.size >= 2) parts[1] else "unknown"
            val toolFunction = if (parts.size >= 3) parts[2] else "unknown"
            
            println("   ğŸ“Š MCP å·¥å…·å®¡è®¡: æœåŠ¡å™¨=$serverName, åŠŸèƒ½=$toolFunction")
            mcpToolWasCalled.set(true)
        }
        
        HookJSONOutput(
            systemMessage = "ğŸ“‹ å®¡è®¡è®°å½•å®Œæˆ",
            hookSpecificOutput = JsonPrimitive("audit_logged")
        )
    }

    /**
     * è·å– MCP æœåŠ¡å™¨è„šæœ¬çš„ç»å¯¹è·¯å¾„
     */
    private fun getMcpServerScript(): String {
        val currentDir = System.getProperty("user.dir")
        return "$currentDir/claude-code-sdk/src/test/resources/simple_mcp_server.py"
    }

    @Test
    fun `test real AI using MCP tools with security hooks`() = runBlocking {
        println("=== ğŸš€ å¼€å§‹çœŸå® MCP + Hooks é›†æˆæµ‹è¯• ===")
        
        // é‡ç½®è®¡æ•°å™¨
        preToolHookCalls.set(0)
        postToolHookCalls.set(0)
        mcpToolWasCalled.set(false)
        securityCheckTriggered.set(false)
        
        // æ¸…ç†æµ‹è¯•æ–‡ä»¶
        val testFile = File(TEST_FILE_PATH)
        testFile.delete()
        
        val mcpServerScript = getMcpServerScript()
        println("MCP æœåŠ¡å™¨è„šæœ¬è·¯å¾„: $mcpServerScript")
        assertTrue(File(mcpServerScript).exists(), "MCP æœåŠ¡å™¨è„šæœ¬åº”è¯¥å­˜åœ¨")
        
        // é…ç½® MCP æœåŠ¡å™¨å’Œ Hooks
        val options = ClaudeCodeOptions(
            model = "claude-3-5-sonnet-20241022",
            
            // MCP æœåŠ¡å™¨é…ç½®
            mcpServers = mapOf(
                "test-server" to McpStdioServerConfig(
                    command = "python3",
                    args = listOf(mcpServerScript),
                    env = mapOf("PYTHONUNBUFFERED" to "1")
                )
            ),
            
            // å…è®¸çš„å·¥å…·ï¼ˆåŒ…æ‹¬ MCP å·¥å…·ï¼‰
            allowedTools = listOf(
                "Read", "Write", "Bash",
                "mcp__test-server__read_file",
                "mcp__test-server__write_file",
                "mcp__test-server__calculate",
                "mcp__test-server__get_time"
            ),
            
            // Hooks é…ç½®
            hooks = mapOf(
                HookEvent.PRE_TOOL_USE to listOf(
                    HookMatcher(
                        matcher = "mcp__.*", // åŒ¹é…æ‰€æœ‰ MCP å·¥å…·
                        hooks = listOf(securityHook)
                    )
                ),
                HookEvent.POST_TOOL_USE to listOf(
                    HookMatcher(
                        matcher = "mcp__.*",
                        hooks = listOf(auditHook)
                    )
                )
            ),
            
            // ç³»ç»Ÿæç¤º
            appendSystemPrompt = """
                ä½ ç°åœ¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ MCP è‡ªå®šä¹‰å·¥å…·ï¼š
                1. test-server.read_file - è¯»å–æ–‡ä»¶å†…å®¹
                2. test-server.write_file - å†™å…¥æ–‡ä»¶å†…å®¹  
                3. test-server.calculate - æ‰§è¡Œæ•°å­¦è®¡ç®—
                4. test-server.get_time - è·å–å½“å‰æ—¶é—´
                
                è¿™äº›å·¥å…·éƒ½ä¼šç»è¿‡å®‰å…¨æ£€æŸ¥å’Œå®¡è®¡è®°å½•ã€‚
                è¯·ä¸¥æ ¼æŒ‰ç…§ç”¨æˆ·çš„æŒ‡ä»¤ä½¿ç”¨è¿™äº›å·¥å…·ã€‚
            """.trimIndent()
        )
        
        val client = ClaudeCodeSdkClient(options)
        
        try {
            println("ğŸ“¡ æ­£åœ¨è¿æ¥åˆ° Claude CLI...")
            client.connect()
            
            println("ğŸ”— è¿æ¥çŠ¶æ€: ${client.isConnected()}")
            assertTrue(client.isConnected(), "åº”è¯¥æˆåŠŸè¿æ¥åˆ° Claude")
            
            val serverInfo = client.getServerInfo()
            println("ğŸ“‹ æœåŠ¡å™¨ä¿¡æ¯: $serverInfo")
            assertNotNull(serverInfo, "åº”è¯¥è·å–åˆ°æœåŠ¡å™¨ä¿¡æ¯")
            
            // æµ‹è¯•1: è¦æ±‚ AI ä½¿ç”¨ MCP å·¥å…·å†™å…¥æ–‡ä»¶
            println("\n--- æµ‹è¯•1: å†™å…¥æ–‡ä»¶ ---")
            val writeMessage = "è¯·ä½¿ç”¨ test-server çš„ write_file å·¥å…·ï¼Œå‘ $TEST_FILE_PATH å†™å…¥å†…å®¹ï¼š$TEST_CONTENT"
            println("ğŸ—£ï¸ å‘é€æ¶ˆæ¯: $writeMessage")
            
            client.query(writeMessage)
            
            var writeTaskCompleted = false
            var aiResponse = ""
            
            withTimeout(45000) { // 45ç§’è¶…æ—¶
                client.receiveResponse().collect { message ->
                    println("ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯ç±»å‹: ${message::class.simpleName}")
                    
                    when (message) {
                        is AssistantMessage -> {
                            message.content.forEach { block ->
                                when (block) {
                                    is TextBlock -> {
                                        aiResponse += block.text
                                        println("ğŸ¤– Claude: ${block.text}")
                                    }
                                    is ToolUseBlock -> {
                                        println("ğŸ”§ Claude è°ƒç”¨å·¥å…·: ${block.name}")
                                        println("   å·¥å…·è¾“å…¥: ${block.input}")
                                        
                                        // éªŒè¯ AI ç¡®å®è°ƒç”¨äº†æˆ‘ä»¬çš„ MCP å·¥å…·
                                        if (block.name.startsWith("mcp__test-server__")) {
                                            println("   âœ… ç¡®è®¤è°ƒç”¨äº† MCP å·¥å…·!")
                                        }
                                    }
                                    else -> {
                                        println("ğŸ“ å…¶ä»–å†…å®¹å—: ${block::class.simpleName}")
                                    }
                                    is ThinkingBlock -> {
                                        println("ğŸ¤” Claude æ€è€ƒ: ${block.thinking}")
                                    }
                                    else -> {
                                        println("ğŸ“ å…¶ä»–å†…å®¹å—: ${block::class.simpleName}")
                                    }
                                    is ToolResultBlock -> {
                                        println("ğŸ”§ å·¥å…·ç»“æœ: ${block.content}")
                                    }
                                }
                            }
                        }
                        is ResultMessage -> {
                            println("ğŸ“Š æ”¶åˆ°ç»“æœæ¶ˆæ¯: ${message.subtype}")
                            if (message.subtype == "success") {
                                writeTaskCompleted = true
                            }
                        }
                        else -> {
                            println("ğŸ“¬ å…¶ä»–æ¶ˆæ¯: ${message::class.simpleName}")
                        }
                    }
                }
            }
            
            assertTrue(writeTaskCompleted, "å†™å…¥ä»»åŠ¡åº”è¯¥å®Œæˆ")
            
            // éªŒè¯æ–‡ä»¶ç¡®å®è¢«åˆ›å»º
            println("\n--- éªŒè¯æ–‡ä»¶åˆ›å»º ---")
            assertTrue(testFile.exists(), "æµ‹è¯•æ–‡ä»¶åº”è¯¥è¢«åˆ›å»º")
            val fileContent = testFile.readText()
            println("ğŸ“„ æ–‡ä»¶å†…å®¹: $fileContent")
            assertTrue(fileContent.contains(TEST_CONTENT), "æ–‡ä»¶å†…å®¹åº”è¯¥åŒ…å«é¢„æœŸæ–‡æœ¬")
            
            // æµ‹è¯•2: è¦æ±‚ AI è¯»å–åˆšæ‰å†™å…¥çš„æ–‡ä»¶
            println("\n--- æµ‹è¯•2: è¯»å–æ–‡ä»¶ ---")
            val readMessage = "è¯·ä½¿ç”¨ test-server çš„ read_file å·¥å…·ï¼Œè¯»å– $TEST_FILE_PATH çš„å†…å®¹"
            println("ğŸ—£ï¸ å‘é€æ¶ˆæ¯: $readMessage")
            
            client.query(readMessage)
            
            var readTaskCompleted = false
            var readResponse = ""
            
            withTimeout(30000) {
                client.receiveResponse().collect { message ->
                    when (message) {
                        is AssistantMessage -> {
                            message.content.forEach { block ->
                                when (block) {
                                    is TextBlock -> {
                                        readResponse += block.text
                                        println("ğŸ¤– Claude: ${block.text}")
                                    }
                                    is ToolUseBlock -> {
                                        println("ğŸ”§ Claude è°ƒç”¨å·¥å…·: ${block.name}")
                                    }
                                    is ThinkingBlock -> {
                                        println("ğŸ¤” Claude æ€è€ƒ: ${block.thinking}")
                                    }
                                    else -> {
                                        println("ğŸ“ å…¶ä»–å†…å®¹å—: ${block::class.simpleName}")
                                    }
                                    is ToolResultBlock -> {
                                        println("ğŸ”§ å·¥å…·ç»“æœ: ${block.content}")
                                    }
                                }
                            }
                        }
                        is ResultMessage -> {
                            if (message.subtype == "success") {
                                readTaskCompleted = true
                            }
                        }
                        else -> {}
                    }
                }
            }
            
            assertTrue(readTaskCompleted, "è¯»å–ä»»åŠ¡åº”è¯¥å®Œæˆ")
            assertTrue(readResponse.contains(TEST_CONTENT), 
                "AI çš„å›å¤åº”è¯¥åŒ…å«æ–‡ä»¶å†…å®¹ï¼Œå®é™…å›å¤ï¼š$readResponse")
            
            // æµ‹è¯•3: è¦æ±‚ AI æ‰§è¡Œæ•°å­¦è®¡ç®—
            println("\n--- æµ‹è¯•3: æ•°å­¦è®¡ç®— ---")
            val calcMessage = "è¯·ä½¿ç”¨ test-server çš„ calculate å·¥å…·ï¼Œè®¡ç®— 15 * 8 çš„ç»“æœ"
            println("ğŸ—£ï¸ å‘é€æ¶ˆæ¯: $calcMessage")
            
            client.query(calcMessage)
            
            var calcTaskCompleted = false
            var calcResponse = ""
            
            withTimeout(30000) {
                client.receiveResponse().collect { message ->
                    when (message) {
                        is AssistantMessage -> {
                            message.content.forEach { block ->
                                when (block) {
                                    is TextBlock -> {
                                        calcResponse += block.text
                                        println("ğŸ¤– Claude: ${block.text}")
                                    }
                                    is ToolUseBlock -> {
                                        println("ğŸ”§ Claude è°ƒç”¨å·¥å…·: ${block.name}")
                                    }
                                    is ThinkingBlock -> {
                                        println("ğŸ¤” Claude æ€è€ƒ: ${block.thinking}")
                                    }
                                    else -> {
                                        println("ğŸ“ å…¶ä»–å†…å®¹å—: ${block::class.simpleName}")
                                    }
                                    is ToolResultBlock -> {
                                        println("ğŸ”§ å·¥å…·ç»“æœ: ${block.content}")
                                    }
                                }
                            }
                        }
                        is ResultMessage -> {
                            if (message.subtype == "success") {
                                calcTaskCompleted = true
                            }
                        }
                        else -> {}
                    }
                }
            }
            
            assertTrue(calcTaskCompleted, "è®¡ç®—ä»»åŠ¡åº”è¯¥å®Œæˆ")
            assertTrue(calcResponse.contains("120"), 
                "AI çš„å›å¤åº”è¯¥åŒ…å«è®¡ç®—ç»“æœ 120ï¼Œå®é™…å›å¤ï¼š$calcResponse")
            
            // éªŒè¯ Hooks è¢«æ­£ç¡®è§¦å‘
            println("\n--- éªŒè¯ Hooks æ‰§è¡Œæƒ…å†µ ---")
            println("ğŸ”’ PRE_TOOL_USE Hook è°ƒç”¨æ¬¡æ•°: ${preToolHookCalls.get()}")
            println("ğŸ“‹ POST_TOOL_USE Hook è°ƒç”¨æ¬¡æ•°: ${postToolHookCalls.get()}")
            println("ğŸ”§ MCP å·¥å…·è¢«è°ƒç”¨: ${mcpToolWasCalled.get()}")
            println("ğŸ›¡ï¸ å®‰å…¨æ£€æŸ¥è¢«è§¦å‘: ${securityCheckTriggered.get()}")
            
            // æ–­è¨€éªŒè¯
            assertTrue(preToolHookCalls.get() > 0, "PRE_TOOL_USE Hook åº”è¯¥è¢«è°ƒç”¨")
            assertTrue(postToolHookCalls.get() > 0, "POST_TOOL_USE Hook åº”è¯¥è¢«è°ƒç”¨")
            assertTrue(mcpToolWasCalled.get(), "MCP å·¥å…·åº”è¯¥è¢«è°ƒç”¨")
            assertTrue(securityCheckTriggered.get(), "å®‰å…¨æ£€æŸ¥åº”è¯¥è¢«è§¦å‘")
            
            println("\nâœ… çœŸå® MCP + Hooks é›†æˆæµ‹è¯•æˆåŠŸï¼")
            
        } catch (e: Exception) {
            println("âŒ æµ‹è¯•å¤±è´¥: ${e.message}")
            e.printStackTrace()
            throw e
        } finally {
            try {
                client.disconnect()
                println("ğŸ”Œ å·²æ–­å¼€è¿æ¥")
                
                // æ¸…ç†æµ‹è¯•æ–‡ä»¶
                testFile.delete()
                println("ğŸ—‘ï¸ å·²æ¸…ç†æµ‹è¯•æ–‡ä»¶")
            } catch (e: Exception) {
                println("âš ï¸ æ¸…ç†æ—¶å‡ºé”™: ${e.message}")
            }
        }
    }
    
    @Test
    fun `test security hook blocks dangerous operations`() = runBlocking {
        println("=== ğŸ›¡ï¸ æµ‹è¯•å®‰å…¨ Hook é˜»æ­¢å±é™©æ“ä½œ ===")
        
        // é‡ç½®çŠ¶æ€
        preToolHookCalls.set(0)
        securityCheckTriggered.set(false)
        
        val mcpServerScript = getMcpServerScript()
        
        val options = ClaudeCodeOptions(
            model = "claude-3-5-sonnet-20241022",
            mcpServers = mapOf(
                "test-server" to McpStdioServerConfig(
                    command = "python3",
                    args = listOf(mcpServerScript),
                    env = mapOf("PYTHONUNBUFFERED" to "1")
                )
            ),
            allowedTools = listOf(
                "mcp__test-server__write_file"
            ),
            hooks = mapOf(
                HookEvent.PRE_TOOL_USE to listOf(
                    HookMatcher(
                        matcher = "mcp__.*",
                        hooks = listOf(securityHook)
                    )
                )
            ),
            appendSystemPrompt = """
                è¯·ä½¿ç”¨ test-server çš„ write_file å·¥å…·ã€‚
                å¦‚æœé‡åˆ°å®‰å…¨é™åˆ¶ï¼Œè¯·å‘Šè¯‰æˆ‘è¢«é˜»æ­¢çš„åŸå› ã€‚
            """.trimIndent()
        )
        
        val client = ClaudeCodeSdkClient(options)
        
        try {
            client.connect()
            assertTrue(client.isConnected())
            
            // å°è¯•å†™å…¥å±é™©è·¯å¾„ï¼ˆåº”è¯¥è¢«é˜»æ­¢ï¼‰
            val dangerousMessage = "è¯·ä½¿ç”¨ write_file å·¥å…·å‘ /etc/passwd å†™å…¥å†…å®¹ 'test'"
            println("ğŸ—£ï¸ å‘é€å±é™©æ“ä½œ: $dangerousMessage")
            
            client.query(dangerousMessage)
            
            var gotSecurityBlock = false
            var aiResponse = ""
            
            withTimeout(30000) {
                client.receiveResponse().collect { message ->
                    when (message) {
                        is AssistantMessage -> {
                            message.content.forEach { block ->
                                when (block) {
                                    is TextBlock -> {
                                        aiResponse += block.text
                                        println("ğŸ¤– Claude: ${block.text}")
                                        
                                        // æ£€æŸ¥æ˜¯å¦åŒ…å«å®‰å…¨é™åˆ¶çš„æç¤º
                                        if (block.text.contains("å®‰å…¨") || 
                                            block.text.contains("é˜»æ­¢") ||
                                            block.text.contains("/tmp/")) {
                                            gotSecurityBlock = true
                                        }
                                    }
                                    is ThinkingBlock -> {
                                        println("ğŸ¤” Claude æ€è€ƒ: ${block.thinking}")
                                    }
                                    else -> {
                                        println("ğŸ“ å…¶ä»–å†…å®¹å—: ${block::class.simpleName}")
                                    }
                                    is ToolResultBlock -> {
                                        println("ğŸ”§ å·¥å…·ç»“æœ: ${block.content}")
                                    }
                                    is ToolUseBlock -> {
                                        println("ğŸ”§ Claude è°ƒç”¨å·¥å…·: ${block.name}")
                                    }
                                }
                            }
                        }
                        is ResultMessage -> {
                            // ç»“æœæ¶ˆæ¯
                        }
                        else -> {}
                    }
                }
            }
            
            assertTrue(securityCheckTriggered.get(), "å®‰å…¨æ£€æŸ¥åº”è¯¥è¢«è§¦å‘")
            assertTrue(preToolHookCalls.get() > 0, "PRE_TOOL_USE Hook åº”è¯¥è¢«è°ƒç”¨")
            println("âœ… å®‰å…¨ Hook æˆåŠŸé˜»æ­¢äº†å±é™©æ“ä½œ")
            
        } finally {
            client.disconnect()
        }
    }
}